UI/UX RESEARCH

Conduct a comprehensive and in-depth research on various viewports and breakpoints across multiple platforms, including mobile devices, desktops, web applications, and other relevant interfaces. Ensure the research covers:
1. Viewport Dimensions: Identify standard and emerging viewport sizes for different devices, considering current industry trends.
2. Breakpoint Analysis: Examine common breakpoints used in responsive design, noting their effectiveness in enhancing user experience.
3. Device Categories: Include a wide range of devices such as smartphones, tablets, laptops, desktops, and large screens.
4. Best Practices: Integrate findings with current UI/UX design best practices to ensure optimal responsiveness and adaptability.
5. Comparative Analysis: Compare how different platforms handle viewports and breakpoints to identify unique challenges and solutions.

Document your findings in a structured format, providing detailed insights, data points, and visual representations where necessary to support the research.





Install and configure all required extensions, mcps, tools, rules, workflows in vscode, GitHub copilot, theia ide, anti gravity.
Install and configure all required extensions, models and other required tools in docker desktop also if required.
Use existing space in hdd and ssd.also install & configure agents like agent zero and other tools vy which acts autnomously without user consent. And find there are any such tools and install then which can help us a lot.LOOPING PROMPT


Iteratively execute the loop until the desired output is consistently achieved, ensuring that each iteration brings measurable improvements or meets the predefined success criteria.

1. Validation of Criteria:

    1. Thoroughly verify that all the previously outlined criteria are fully met and valid.

    2. Implement checkpoints to regularly assess adherence to these criteria throughout the process.

2. Grammatical and Spelling Review:

    1. Conduct a meticulous review for any grammatical or spelling errors.

    2. If errors are identified, promptly rewrite the affected sections to ensure grammatical correctness and clarity.

3. Optimization Without Compromising Goals:

    1. Evaluate the current output to identify potential areas for optimization.

    2. Apply optimization techniques cautiously to enhance performance or clarity without disturbing the core objectives or altering the intended outcome.

4. Adherence to Best Practices:

    1. Consistently follow industry-standard best practices relevant to the task.

    2. Stay updated with the latest methodologies and incorporate them where applicable to improve overall efficiency and effectiveness.


NOTES TAKING

TANA
KORTEX


I am utilizing an Apple MacBook Pro with the M1 Pro chip, featuring 16 GB of unified memory and 995 GB (1 TB) of storage, specifically the 14-inch 2021 model. Additionally, I have a Samsung 1 TB SSD and a Seagate 1 TB portable hard disk at my disposal. My objective is to establish a robust setup for research, coding, and development activities, leveraging both open-source/free and paid models on my system. This setup will involve utilizing various tools, including MCPs, A2A, open-source tools, and other methodologies. I require a comprehensive and advanced research analysis on models, tools, open-source tools, frameworks, and other resources that align with my specific requirements and the constraints of my hardware and software. If my current software and hardware capabilities are insufficient, please also propose alternative methods to extend or utilize online services such as Hugging Face and others to meet my needs effectively.




qwen3-4b-thinking-2507

Qwen3-Coder-480B-A35B-Instruct-UD-IQ1_M.gguf


RoboForm’s forever-free plan vs Proton Free plan vs Bitwarden free plan

AGENTS


Create an claude agent for : “ periodically scan through the entire codebase.
Research on those areas on internet and other sources for imrpovement & production grade performance.
Implement those practices into the project.
And find and fix those issues.
Re-iterate until we achieve production grade quality solutions/software.”.



Create an claude agent for : “

Tracking all the planning, execution, implementation of development like in task master and other task management tools or agent.
This task management should have advanced features and functionalities.
Do a well-rounded/advanced research on this use case and implement from other task management tools Agent.
And find and fix those issues.
Re-iterate until we achieve production grade quality solutions/software.”.


Conduct a comprehensive analysis of the entire codebase to identify any leftover tasks, pending items, incomplete features, and unimplemented functionalities. Apply industry-standard best practices throughout the process, including:
1. Code Review: Systematically examine code for annotations like TODOs, FIXMEs, and comments indicating incomplete work.
2. Automated Tools: Utilize static code analysis tools, linters, and code quality scanners to detect overlooked code sections.
3. Dependency Mapping: Analyze dependencies to uncover deprecated libraries or unintegrated modules.
4. Version Control History: Review commit logs to track unfinished features and pending merges.
5. Issue Tracking Integration: Cross-reference with task management tools to align identified gaps with existing tickets.
6. Documentation Review: Compare current documentation with the codebase to highlight discrepancies indicating missing elements.
7. Performance Analysis: Conduct performance profiling to detect under-optimized areas likely representing incomplete implementations.

Ensure continuous iteration and refinement of this process to maintain production-grade quality and comprehensive coverage across the codebase.


Objective:

Instruct AI tools to seamlessly integrate contextual information, summarizations, and task-related data directly into task management systems, avoiding the creation of redundant or excessive files. This ensures streamlined workflows and effective resource management.

Prompt:

"You are tasked with managing and processing data efficiently. When handling context, summarization, and task-related information:
1. Direct Integration: Instead of generating separate files for each context or task, integrate the information directly into the designated task management system.
    * Utilize structured data fields within the system for summaries, notes, and task statuses.
    * Link related tasks contextually without external file dependencies.
2. Fail-Safe Mechanism: If direct integration is not feasible due to system limitations:
    * Track the files you create meticulously.
    * Implement an automated cleanup process to delete these files once the data has been successfully migrated or is no longer needed.
3. Continuous Monitoring:
    * Periodically verify that no orphan files are left in the system.
    * Adapt and refine the integration process to reduce the occurrence of unnecessary file creation over time.

Ensure all actions maintain data integrity, support collaborative workflows, and align with production-grade quality standards."

Result:

This prompt promotes efficient data handling, minimizes clutter, and enhances task management effectiveness while providing fallback protocols for exceptions.




1. Macro Tasks: High-level objectives encompassing broader goals.
* Define the overall project goal.
* Identify key components or phases.
* Outline major deliverables.

2. Micro Tasks: Smaller, detailed activities within macro tasks.
* Break down each macro task into specific actions.
* Assign responsibilities and deadlines.
* Prioritize tasks based on dependencies.

3. Small Tasks: Granular, actionable steps for execution.
* List step-by-step instructions for each micro task.
* Set clear, concise goals for each small task.
* Ensure tasks are manageable within short timeframes.

Guidelines
* Suitability for Claude Max 5x Plan:
    * Ensure each breakdown fits within token limitations.
    * Focus on concise, relevant content.
* Avoiding Token Overflow:
    * Keep task descriptions brief and clear.
    * Use bullet points for easy readability.
    * Group related tasks efficiently to maintain context.

1. Validation of Criteria:

    1. Thoroughly verify that all the previously outlined criteria are fully met and valid.

    2. Implement checkpoints to regularly assess adherence to these criteria throughout the process.

2. Grammatical and Spelling Review:

    1. Conduct a meticulous review for any grammatical or spelling errors.

    2. If errors are identified, promptly rewrite the affected sections to ensure grammatical correctness and clarity.

3. Optimization Without Compromising Goals:

    1. Evaluate the current output to identify potential areas for optimization.

    2. Apply optimization techniques cautiously to enhance performance or clarity without disturbing the core objectives or altering the intended outcome.

4. Adherence to Best Practices:

    1. Consistently follow industry-standard best practices relevant to the task.

    2. Stay updated with the latest methodologies and incorporate them where applicable to improve overall efficiency and effectiveness.

LOOPING PROMPT


Iteratively execute the loop until the desired output is consistently achieved, ensuring that each iteration brings measurable improvements or meets the predefined success criteria.

1. Validation of Criteria:

    1. Thoroughly verify that all the previously outlined criteria are fully met and valid.

    2. Implement checkpoints to regularly assess adherence to these criteria throughout the process.

2. Grammatical and Spelling Review:

    1. Conduct a meticulous review for any grammatical or spelling errors.

    2. If errors are identified, promptly rewrite the affected sections to ensure grammatical correctness and clarity.

3. Optimization Without Compromising Goals:

    1. Evaluate the current output to identify potential areas for optimization.

    2. Apply optimization techniques cautiously to enhance performance or clarity without disturbing the core objectives or altering the intended outcome.

4. Adherence to Best Practices:

    1. Consistently follow industry-standard best practices relevant to the task.

    2. Stay updated with the latest methodologies and incorporate them where applicable to improve overall efficiency and effectiveness.




ROUGH ROUGH


- **Building and Selling Digital Products**: Developers can create and sell templates, code snippets, plugins, or AI prompt packs on platforms like Gumroad, Envato, or Etsy. These products can be developed quickly using AI tools and generate passive income through one-time or recurring sales 
- **Freelancing and Contract Work**: Platforms like Upwork, Fiverr, Toptal, and Freelance.dev remain popular for securing short-term gigs and long-term contracts. Specializing in high-demand niches such as SaaS dashboards, e-commerce solutions, or AI integration can significantly increase earning potential and client retention 
- **Creating SaaS (Software as a Service) Products**: Developing focused Micro-SaaS applications that solve specific problems for a niche audience can generate consistent monthly recurring revenue through subscriptions. Success depends on solving real pain points and using automated systems for subscription management and customer retention 
- **Content Creation and Education**: Writing technical blogs, launching newsletters, or creating video courses on platforms like Udemy, YouTube, or Gumroad allows developers to monetize their expertise. Content can be monetized through ads, sponsorships, affiliate marketing, or paid memberships 
- **Leveraging AI and Web3 Technologies**: With the rise of AI-as-a-Service (AIaaS) platforms like OpenAI and Hugging Face, developers can build intelligent applications that are monetized via subscriptions or usage fees. In the Web3 space, opportunities include launching personal projects, securing grants, freelancing in non-crypto industries like real estate or science, or contributing non-code work such as technical writing and community management 
- **Open Source Sponsorships**: Contributing to open-source projects can lead to financial support through platforms like GitHub Sponsors or Patreon, especially if the project gains traction within the developer community 

In 2025, developers can leverage their skills to build **multiple income streams** beyond traditional employment, combining **freelancing, passive income, and emerging tech like AI and Web3**. The most effective strategies focus on **scalability and automation**, allowing you to earn while minimizing ongoing time investment.

## Step-by-step instructions

### Prerequisites
- A solid foundation in at least one programming language (e.g., JavaScript, Python)
- Access to platforms like GitHub, Gumroad, or Udemy
- Basic understanding of marketing and audience building (content, SEO, social media)

### 1. Start Freelancing for Immediate Income
- Sign up on platforms like **Upwork, Fiverr, or Toptal**.
- Create a strong profile highlighting your niche (e.g., “React Developer” or “Python Automation Expert”).
- Begin with small projects to build reviews and credibility.
- Gradually increase your rates as you gain experience and testimonials.
- Use earnings to fund passive income projects.

### 2. Build and Sell Digital Products (Passive Income)
- Identify reusable code assets: **templates, UI kits, VS Code extensions, or AI prompt packs**.
- Package them for sale on **Gumroad, Etsy, or Creative Market**.
- Automate delivery and licensing using platforms like **Lemon Squeezy or PayPro Global**.
- Promote via social media, developer forums, or YouTube.

### 3. Launch a Micro-SaaS or AI-Powered Tool
- Solve a specific problem (e.g., AI resume parser, documentation generator).
- Use modern stacks: **Next.js + Supabase/Firebase + OpenAI API + Stripe**.
- Deploy quickly using low-code tools and pre-built UI components.
- Monetize via **monthly subscriptions**.
- Launch on **Product Hunt or Indie Hackers** for visibility.

### 4. Create Educational Content
- Start a **YouTube channel, blog, or newsletter** focused on coding tutorials or tech trends.
- Cover topics like “How I built an AI Chrome extension in 24 hours” or “Top 10 VS Code extensions in 2025.”
- Monetize through **ads, affiliate marketing (e.g., hosting services, IDEs), sponsorships, or paid memberships**.
- Repurpose content into **mini-courses on Udemy or Teachable**.

### 5. Explore Web3 and Blockchain Opportunities
- Build open-source tools for blockchain (e.g., ZK proof helpers) and apply for **grants from protocols like Mina or Ethereum**.
- Offer freelance services to **non-crypto industries adopting blockchain**, such as real estate or decentralized science (DeSci).
- Take on **technical writing, devrel, or educational content roles** for Web3 projects—skills in both coding and communication are highly valued.

### 6. Monetize Open Source Contributions
- Build useful libraries or tools and publish them on **GitHub**.
- Enable **GitHub Sponsors or Patreon** for recurring support.
- Attract sponsors by documenting usage, sharing tutorials, and engaging the community.

https://blog.payproglobal.com/passive-income-ideas-for-software-developers

https://medium.com/illumination/10-ways-to-earn-money-in-2025-as-a-developer-df0a7077a415

https://www.podia.com/articles/earn-more-as-developer

https://www.nobledesktop.com/blog/how-to-make-more-money-in-web-development

https://www.clickfunnels.com/blog/make-money-web-developer/

https://adapty.io/blog/how-to-make-more-money-as-app-developer/

https://www.nobledesktop.com/blog/how-to-make-more-money-in-web-development

https://dev.to/codedarmab101/how-to-make-money-as-a-developer-in-2025-381a

https://platform.text.com/resource-center/updates/how-to-make-money-coding

https://www.effectivebusinessideas.com/10-profitable-way-to-make-money-with-software-engineering-in-2025/

https://medium.com/@irenemmassyy/3-newest-ways-to-earn-money-as-a-developer-in-2025-0595b07cce12

https://blog.stackademic.com/how-i-would-start-earning-money-as-a-developer-with-0-in-2025-2026-4d9c3759e935

https://www.reddit.com/r/csharp/comments/16bjjy3/how_can_i_earn_extra_money_on_the_side_as_a/

https://medium.com/@nanakwabenaaboraah/10-powerful-ways-to-make-money-as-a-developer-beyond-the-9-to-5-12e8989ff154

https://www.youtube.com/watch?v=A4_TFHzqAAg

https://www.wearedevelopers.com/en/magazine/572/how-to-make-extra-money-as-a-developer-freelancing-contract-work-572

https://medium.com/@devdo/passive-income-ideas-for-developers-that-actually-work-in-2025-2cf281c14412

https://www.youtube.com/watch?v=B7TXOq6caNE

https://dev.to/code_area_9036c9663233d92/the-best-way-to-earn-money-online-as-a-developer-in-2025-3dcp

https://hackernoon.com/ways-to-make-money-as-a-developer-a93p3uqa

https://brianjenney.medium.com/how-you-can-start-a-5-figure-side-business-as-software-engineer-15b5634f3821

https://buymeacoffee.com/codelearner/top-10-ways-make-money-frontend-developer-2025

https://www.youtube.com/watch?v=O0p5rV7iW58

https://dev.to/lissy93/50-ways-to-bring-in-extra-cash-as-a-developer-19b6

https://www.afternerd.com/blog/side-income-programmers/

https://startupgrowthguide.com/how-to-make-money-online-the-ultimate-guide-for-developers-and-programmers/

https://mindsers.blog/en/post/7-ways-make-money-as-developer/

https://www.coryzue.com/writing/solopreneur/

https://diggitymarketing.com/how-to-make-money-online/from-coding/

https://www.techloy.com/top-software-development-jobs-to-consider-in-2025/

https://winatalent.com/blog/how-to-make-money-as-a-programmer/

https://www.florin-pop.com/blog/2019/08/ways-to-make-money-as-a-developer/

https://zerocodeinstitute.com/6-best-skills-to-make-money-online-in-2025/

https://dev.to/lokesh_singh/turn-your-code-into-cash-25-money-making-ideas-for-developers-2gm5

https://www.indeed.com/career-advice/career-development/software-engineer-side-hustle

https://www.quora.com/How-do-you-think-I-can-make-money-fast-as-a-developer

https://medium.com/@ssefaekici/from-side-project-to-full-time-income-how-developers-monetize-skills-in-2025-ed956b3b8623

https://www.youtube.com/watch?v=zQZluEJaCgs

https://dev.to/code_2/11-powerful-ways-to-make-money-online-as-a-developer-that-actually-work-22ke


INSTRUCTIONS FOR AI TOOL TO NOT TO DEFAULT PYTHON


1. Task

You will receive a problem description:
Problem Description:{{problem_description}}
Your job is to:
1. Understand the problem and its constraints.
2. Evaluate multiple suitable programming languages.
3. Compare and rank them for this specific use case.
4. Choose the most appropriate language(s) and justify the choice.
5. Only then, produce code and detailed guidance in the chosen language(s).

2. Hard Rules (Non-Negotiable)

1. Do not default to Python.
    * You must explicitly consider multiple languages before picking any one language.
    * You must treat Python as one candidate among many, not the default.
2. Use Python only when truly justified.
    * Use Python only if your comparison and ranking clearly shows Python is the best choice for this exact problem and constraints.
    * If Python is not ranked #1, you must not use Python for the main solution.
3. Check for alternative languages.
    * Assume by default that the solution can be implemented in multiple languages (C, C++, Rust, Go, Java, Kotlin, TypeScript/Node.js, C#, etc.).
    * If you have internet access / browsing:
        * Search the web to confirm which languages are commonly used for this kind of problem.
        * Use that information to update your ranking and mention the sources at a high level (no links needed, just names and quick reference).
    * If you do not have internet access:
        * Explicitly state that you are relying on your internal knowledge without live web verification.
4. Explain your reasoning clearly.
    * You must show your reasoning step-by-step for:
        * How you understood the problem.
        * How you selected candidate languages.
        * How you ranked them.
        * Why you chose the final language(s).
    * Do not skip directly to code.
5. If multiple components exist, you may choose multiple languages.
    * Example: backend API in Go, data pipeline in Rust, frontend in TypeScript/React.
    * Clearly explain which language is used for which component and why.

3. Language Selection and Comparison Process

Before writing any code, follow this exact sequence:

3.1 Identify Candidate Languages

Create a list of at least 3–5 reasonable candidate languages for this problem.When relevant, consider languages from different categories, such as:
* Systems / high-performance: C, C++, Rust
* Backend / services: Go, Java, Kotlin, C#, Rust
* Scripting / glue / automation: Python, JavaScript/TypeScript (Node.js), Ruby
* Frontend / UI: TypeScript/JavaScript (React, Vue, Angular, Svelte), etc.
* Data / analytics: Python, R, Julia, Rust, etc.
You may add others if they are appropriate.

3.2 Define Evaluation Criteria

For this specific problem, evaluate each language using these criteria (adapt or extend if needed):
* Runtime performance: latency, throughput, memory usage.
* Developer productivity: speed of development, simplicity.
* Ecosystem & libraries: maturity and availability of libraries/frameworks for this use case.
* Maintainability & readability: long-term code health, clarity.
* Tooling & debugging: IDE support, debuggers, profilers, linters.
* Reliability & safety: type system, memory safety, error handling.
* Concurrency & scalability: if applicable for this problem.
* Interoperability: integration with other systems/languages in the stack.
* Deployment & hosting: ease of running in containers, cloud, serverless, etc.
* Team skill assumptions (if provided by user): if user mentions preferred or known languages, factor that in.

3.3 Build a Comparison Table

Produce a small table where rows = languages and columns = criteria.AdvancedSimple Guide to Writing a Strong Problem Statement
To turn rough ideas into a clear, detailed, and effective problem statement, follow these easy steps. This process helps ensure your problem statement is easy to understand, accurate, and professional.
1. Keep Improving with Feedback:
    * Make Small Changes Often: Work on your problem statement in steps, improving it a little each time.
    * Check for Progress: After each update, see if it’s clearer and more complete than before.
    * Use Feedback: Ask others for their thoughts and use their suggestions to make it better.
2. Check That It Meets Key Points:
    * Stay on Topic: Make sure the problem statement is relevant and makes sense.
    * Review Regularly: Set times to review your work and see if it’s still on track.
    * Get Different Opinions: Use tools and ask others to review your work to catch mistakes you might miss.
3. Check Grammar and Spelling:
    * Proofread Carefully: Read through your problem statement to catch any grammar or spelling mistakes.
    * Use Tools: Use spelling and grammar checkers for extra help.
    * Fix and Improve: When you find mistakes, rewrite the parts to make them clearer and easier to read.
4. Make It Clear Without Losing Meaning:
    * Look for Ways to Improve: Check if you can say things more simply or clearly without changing the meaning.
    * Be Careful: Make small changes to improve clarity without removing important details.
    * Double-Check: After changes, make sure the problem statement still matches your main goals.
5. Follow Best Practices:
    * Be Clear and Direct: Use simple, direct language and organize your ideas logically.
    * Stay Updated: Keep learning new ways to write better problem statements.
    * Keep Learning: Always look for ways to improve your skills and keep up with new trends.

By following these steps, you’ll create a problem statement that’s clear, complete, and professional. Problem Statement Development Framework
To transform raw statements into a well-structured, advanced, and complete problem statement, a systematic approach grounded in industry best practices is essential. This ensures the problem statement achieves clarity, precision, and effectiveness.

1. Iterative Refinement Process:
* Continuous Improvement: Apply iterative development cycles to progressively enhance the problem statement’s clarity, completeness, and accuracy.
* Measurable Outcomes: Each iteration should yield tangible improvements based on predefined success metrics such as coherence, relevance, and completeness.
* Feedback Mechanisms: Integrate feedback loops in every cycle to ensure constructive evolution of the problem statement.

2. Rigorous Validation of Criteria:
* Comprehensive Evaluation: Ensure all outlined criteria—relevance to the subject matter, logical consistency, and scope alignment—are fully met.
* Systematic Checkpoints: Establish evaluation checkpoints throughout the refinement process to systematically assess adherence to critical criteria.
* Objective Validation: Employ both automated tools and peer reviews to maintain objectivity and depth in the validation process.

3. Grammatical and Spelling Accuracy:
* Detailed Reviews: Conduct meticulous reviews focusing on grammar, syntax, and spelling to uphold superior language quality.
* Advanced Proofreading Tools: Utilize sophisticated proofreading techniques and tools to detect subtle errors.
* Precision Rewrites: When errors are identified, implement precise rewrites to enhance clarity, readability, and professional tone.

4. Strategic Optimization Without Compromising Core Objectives:
* Performance Analysis: Identify opportunities to optimize for conciseness, logical flow, and overall impact.
* Cautious Implementation: Apply optimization strategies that enhance clarity and performance without altering the problem’s core objectives.
* Alignment Checks: Regularly review optimized content to ensure strong alignment with fundamental goals.

5. Adherence to Industry Best Practices:
* Consistent Application: Apply best practices in problem statement development, focusing on clarity of purpose, precise terminology, and logical structuring.
* Stay Updated: Keep abreast of emerging methodologies to maintain efficiency, effectiveness, and relevance.
* Continuous Learning: Foster an environment of continuous learning to adapt to evolving industry standards and practices.

By meticulously applying these structured principles, the refined problem statement will be comprehensive, accurate, and aligned with the highest standards of professional excellence.
Include short notes, not essays, such as:
Language	Performance	Ecosystem	Dev Speed	Safety	Concurrency	Deployment	Notes
Rust	Very high	Good	Medium	Strong	Strong	Good	Great for low-latency, safe systems.
Go	High	Very good	High	Good	Strong	Excellent	Simple, great for web services.
Python	Medium/low	Excellent	Very high	Medium	Limited	Good	Fast to prototype, slower runtime.
Adjust based on the problem.

3.4 Rank the Languages

For this specific use case, provide a ranked list:

Language Ranking for This Problem
1. Language A – with justification
2. Language B – with justification
3. Language C – with justification

Make sure the ranking is based on the actual problem, not on general popularity.

3.5 Choose the Final Language(s)

From the ranking:
* Pick the top 1–2 languages and explicitly justify:
    * Why they are best for this exact problem.
    * Why you are not choosing the others.
* After choosing:
    * Lock in the language(s) and use them consistently in the rest of the answer.
Python-specific rule:If Python is not ranked #1, you must not pick Python as the primary implementation language.If Python is ranked #1, explicitly state why (e.g., heavy ML usage, fastest iteration, existing Python ecosystem, etc.).

4. Implementation Guidelines
Once the language(s) are chosen, then and only then:
1. High-level design first.
    * Show the architecture.
    * Show modules/components.
    * Explain data flow and major responsibilities.
2. Then code.
    * Provide well-structured, production-oriented examples, not toy snippets.
    * Include:
        * Project structure (folders, files).
        * Core code examples.
        * Any important config (build tools, package managers, Dockerfile outline, etc.).
    * Write idiomatic code following best practices for that language.
3. Performance & scalability notes.
    * Explain how the chosen language and design will handle:
        * Expected load.
        * Scaling (horizontal/vertical).
        * Performance optimizations were relevant.
4. Testing & CI/CD.
    * Recommend testing strategies and libraries for this language.
    * Outline how this code can be integrated into CI/CD pipelines.
    * Mention static analysis / linters / formatters for that language.

5. Web / Research Requirement (If Available)

If the AI system has web access:
1. Search for real-world usage of this problem type in different languages:
    * Example: “high performance REST API in Rust vs Go”, “ML serving in Python vs Java”, etc.
2. Use findings to:
    * Validate your language choices.
    * Reference common patterns, frameworks, or well-known tools.
3. If research contradicts your initial ranking, update your ranking and explain the change.
If web access is not available, explicitly state:
“Web access is not available. I am using my internal knowledge without live verification.”

6. Output Format

Always structure your response in this order:
1. Problem Understanding
    * Short summary of what needs to be built.
2. Candidate Languages & Criteria
    * List of languages considered.
    * The evaluation criteria used.
3. Comparison Table
    * A compact table comparing languages.
4. Ranking & Final Choice
    * Ranked list.
    * Explanation of the final chosen language(s).
    * Explicit mention of why Python is or is not chosen.
5. High-Level Design
    * Architecture.
    * Components/modules.
6. Implementation in Chosen Language(s)
    * Project structure.
    * Code examples.
    * Important configs.
7. Performance, Testing, and Deployment Notes
    * Optimization ideas.
    * Testing strategies.
    * CI/CD and deployment guidance.

If the user later asks specifically for code in another language (e.g., “now show this in Rust instead of Go”), you may provide an additional implementation in that requested language, and you should say how the trade-offs change.create claude agents required for the project as per the context.before starting to code for the project, gather everything which are all required for an reduction grade solution.don’t start a new project here, this repo is only for research, move to GitHub create a new repo and start coding there once everything is cooked and ready.

use required model for research & coding. remember we have claude max 5x plan so plan accrodingly so we don't out of token and context.

ROUGH ROUGH


- **Building and Selling Digital Products**: Developers can create and sell templates, code snippets, plugins, or AI prompt packs on platforms like Gumroad, Envato, or Etsy. These products can be developed quickly using AI tools and generate passive income through one-time or recurring sales 
- **Freelancing and Contract Work**: Platforms like Upwork, Fiverr, Toptal, and Freelance.dev remain popular for securing short-term gigs and long-term contracts. Specializing in high-demand niches such as SaaS dashboards, e-commerce solutions, or AI integration can significantly increase earning potential and client retention 
- **Creating SaaS (Software as a Service) Products**: Developing focused Micro-SaaS applications that solve specific problems for a niche audience can generate consistent monthly recurring revenue through subscriptions. Success depends on solving real pain points and using automated systems for subscription management and customer retention 
- **Content Creation and Education**: Writing technical blogs, launching newsletters, or creating video courses on platforms like Udemy, YouTube, or Gumroad allows developers to monetize their expertise. Content can be monetized through ads, sponsorships, affiliate marketing, or paid memberships 
- **Leveraging AI and Web3 Technologies**: With the rise of AI-as-a-Service (AIaaS) platforms like OpenAI and Hugging Face, developers can build intelligent applications that are monetized via subscriptions or usage fees. In the Web3 space, opportunities include launching personal projects, securing grants, freelancing in non-crypto industries like real estate or science, or contributing non-code work such as technical writing and community management 
- **Open Source Sponsorships**: Contributing to open-source projects can lead to financial support through platforms like GitHub Sponsors or Patreon, especially if the project gains traction within the developer community 

In 2025, developers can leverage their skills to build **multiple income streams** beyond traditional employment, combining **freelancing, passive income, and emerging tech like AI and Web3**. The most effective strategies focus on **scalability and automation**, allowing you to earn while minimizing ongoing time investment.

## Step-by-step instructions

### Prerequisites
- A solid foundation in at least one programming language (e.g., JavaScript, Python)
- Access to platforms like GitHub, Gumroad, or Udemy
- Basic understanding of marketing and audience building (content, SEO, social media)

### 1. Start Freelancing for Immediate Income
- Sign up on platforms like **Upwork, Fiverr, or Toptal**.
- Create a strong profile highlighting your niche (e.g., “React Developer” or “Python Automation Expert”).
- Begin with small projects to build reviews and credibility.
- Gradually increase your rates as you gain experience and testimonials.
- Use earnings to fund passive income projects.

### 2. Build and Sell Digital Products (Passive Income)
- Identify reusable code assets: **templates, UI kits, VS Code extensions, or AI prompt packs**.
- Package them for sale on **Gumroad, Etsy, or Creative Market**.
- Automate delivery and licensing using platforms like **Lemon Squeezy or PayPro Global**.
- Promote via social media, developer forums, or YouTube.

### 3. Launch a Micro-SaaS or AI-Powered Tool
- Solve a specific problem (e.g., AI resume parser, documentation generator).
- Use modern stacks: **Next.js + Supabase/Firebase + OpenAI API + Stripe**.
- Deploy quickly using low-code tools and pre-built UI components.
- Monetize via **monthly subscriptions**.
- Launch on **Product Hunt or Indie Hackers** for visibility.

### 4. Create Educational Content
- Start a **YouTube channel, blog, or newsletter** focused on coding tutorials or tech trends.
- Cover topics like “How I built an AI Chrome extension in 24 hours” or “Top 10 VS Code extensions in 2025.”
- Monetize through **ads, affiliate marketing (e.g., hosting services, IDEs), sponsorships, or paid memberships**.
- Repurpose content into **mini-courses on Udemy or Teachable**.

### 5. Explore Web3 and Blockchain Opportunities
- Build open-source tools for blockchain (e.g., ZK proof helpers) and apply for **grants from protocols like Mina or Ethereum**.
- Offer freelance services to **non-crypto industries adopting blockchain**, such as real estate or decentralized science (DeSci).
- Take on **technical writing, devrel, or educational content roles** for Web3 projects—skills in both coding and communication are highly valued.

### 6. Monetize Open Source Contributions
- Build useful libraries or tools and publish them on **GitHub**.
- Enable **GitHub Sponsors or Patreon** for recurring support.
- Attract sponsors by documenting usage, sharing tutorials, and engaging the community.

https://blog.payproglobal.com/passive-income-ideas-for-software-developers

https://medium.com/illumination/10-ways-to-earn-money-in-2025-as-a-developer-df0a7077a415

https://www.podia.com/articles/earn-more-as-developer

https://www.nobledesktop.com/blog/how-to-make-more-money-in-web-development

https://www.clickfunnels.com/blog/make-money-web-developer/

https://adapty.io/blog/how-to-make-more-money-as-app-developer/

https://www.nobledesktop.com/blog/how-to-make-more-money-in-web-development

https://dev.to/codedarmab101/how-to-make-money-as-a-developer-in-2025-381a

https://platform.text.com/resource-center/updates/how-to-make-money-coding

https://www.effectivebusinessideas.com/10-profitable-way-to-make-money-with-software-engineering-in-2025/

https://medium.com/@irenemmassyy/3-newest-ways-to-earn-money-as-a-developer-in-2025-0595b07cce12

https://blog.stackademic.com/how-i-would-start-earning-money-as-a-developer-with-0-in-2025-2026-4d9c3759e935

https://www.reddit.com/r/csharp/comments/16bjjy3/how_can_i_earn_extra_money_on_the_side_as_a/

https://medium.com/@nanakwabenaaboraah/10-powerful-ways-to-make-money-as-a-developer-beyond-the-9-to-5-12e8989ff154

https://www.youtube.com/watch?v=A4_TFHzqAAg

https://www.wearedevelopers.com/en/magazine/572/how-to-make-extra-money-as-a-developer-freelancing-contract-work-572

https://medium.com/@devdo/passive-income-ideas-for-developers-that-actually-work-in-2025-2cf281c14412

https://www.youtube.com/watch?v=B7TXOq6caNE

https://dev.to/code_area_9036c9663233d92/the-best-way-to-earn-money-online-as-a-developer-in-2025-3dcp

https://hackernoon.com/ways-to-make-money-as-a-developer-a93p3uqa

https://brianjenney.medium.com/how-you-can-start-a-5-figure-side-business-as-software-engineer-15b5634f3821

https://buymeacoffee.com/codelearner/top-10-ways-make-money-frontend-developer-2025

https://www.youtube.com/watch?v=O0p5rV7iW58

https://dev.to/lissy93/50-ways-to-bring-in-extra-cash-as-a-developer-19b6

https://www.afternerd.com/blog/side-income-programmers/

https://startupgrowthguide.com/how-to-make-money-online-the-ultimate-guide-for-developers-and-programmers/

https://mindsers.blog/en/post/7-ways-make-money-as-developer/

https://www.coryzue.com/writing/solopreneur/

https://diggitymarketing.com/how-to-make-money-online/from-coding/

https://www.techloy.com/top-software-development-jobs-to-consider-in-2025/

https://winatalent.com/blog/how-to-make-money-as-a-programmer/

https://www.florin-pop.com/blog/2019/08/ways-to-make-money-as-a-developer/

https://zerocodeinstitute.com/6-best-skills-to-make-money-online-in-2025/

https://dev.to/lokesh_singh/turn-your-code-into-cash-25-money-making-ideas-for-developers-2gm5

https://www.indeed.com/career-advice/career-development/software-engineer-side-hustle

https://www.quora.com/How-do-you-think-I-can-make-money-fast-as-a-developer

https://medium.com/@ssefaekici/from-side-project-to-full-time-income-how-developers-monetize-skills-in-2025-ed956b3b8623

https://www.youtube.com/watch?v=zQZluEJaCgs

https://dev.to/code_2/11-powerful-ways-to-make-money-online-as-a-developer-that-actually-work-22ke


INSTRUCTIONS FOR AI TOOL TO NOT TO DEFAULT PYTHON


1. Task

You will receive a problem description:
Problem Description:{{problem_description}}
Your job is to:
1. Understand the problem and its constraints.
2. Evaluate multiple suitable programming languages.
3. Compare and rank them for this specific use case.
4. Choose the most appropriate language(s) and justify the choice.
5. Only then, produce code and detailed guidance in the chosen language(s).

2. Hard Rules (Non-Negotiable)

1. Do not default to Python.
    * You must explicitly consider multiple languages before picking any one language.
    * You must treat Python as one candidate among many, not the default.
2. Use Python only when truly justified.
    * Use Python only if your comparison and ranking clearly shows Python is the best choice for this exact problem and constraints.
    * If Python is not ranked #1, you must not use Python for the main solution.
3. Check for alternative languages.
    * Assume by default that the solution can be implemented in multiple languages (C, C++, Rust, Go, Java, Kotlin, TypeScript/Node.js, C#, etc.).
    * If you have internet access / browsing:
        * Search the web to confirm which languages are commonly used for this kind of problem.
        * Use that information to update your ranking and mention the sources at a high level (no links needed, just names and quick reference).
    * If you do not have internet access:
        * Explicitly state that you are relying on your internal knowledge without live web verification.
4. Explain your reasoning clearly.
    * You must show your reasoning step-by-step for:
        * How you understood the problem.
        * How you selected candidate languages.
        * How you ranked them.
        * Why you chose the final language(s).
    * Do not skip directly to code.
5. If multiple components exist, you may choose multiple languages.
    * Example: backend API in Go, data pipeline in Rust, frontend in TypeScript/React.
    * Clearly explain which language is used for which component and why.

3. Language Selection and Comparison Process

Before writing any code, follow this exact sequence:

3.1 Identify Candidate Languages

Create a list of at least 3–5 reasonable candidate languages for this problem.When relevant, consider languages from different categories, such as:
* Systems / high-performance: C, C++, Rust
* Backend / services: Go, Java, Kotlin, C#, Rust
* Scripting / glue / automation: Python, JavaScript/TypeScript (Node.js), Ruby
* Frontend / UI: TypeScript/JavaScript (React, Vue, Angular, Svelte), etc.
* Data / analytics: Python, R, Julia, Rust, etc.
You may add others if they are appropriate.

3.2 Define Evaluation Criteria

For this specific problem, evaluate each language using these criteria (adapt or extend if needed):
* Runtime performance: latency, throughput, memory usage.
* Developer productivity: speed of development, simplicity.
* Ecosystem & libraries: maturity and availability of libraries/frameworks for this use case.
* Maintainability & readability: long-term code health, clarity.
* Tooling & debugging: IDE support, debuggers, profilers, linters.
* Reliability & safety: type system, memory safety, error handling.
* Concurrency & scalability: if applicable for this problem.
* Interoperability: integration with other systems/languages in the stack.
* Deployment & hosting: ease of running in containers, cloud, serverless, etc.
* Team skill assumptions (if provided by user): if user mentions preferred or known languages, factor that in.

3.3 Build a Comparison Table

Produce a small table where rows = languages and columns = criteria.AdvancedSimple Guide to Writing a Strong Problem Statement
To turn rough ideas into a clear, detailed, and effective problem statement, follow these easy steps. This process helps ensure your problem statement is easy to understand, accurate, and professional.
1. Keep Improving with Feedback:
    * Make Small Changes Often: Work on your problem statement in steps, improving it a little each time.
    * Check for Progress: After each update, see if it’s clearer and more complete than before.
    * Use Feedback: Ask others for their thoughts and use their suggestions to make it better.
2. Check That It Meets Key Points:
    * Stay on Topic: Make sure the problem statement is relevant and makes sense.
    * Review Regularly: Set times to review your work and see if it’s still on track.
    * Get Different Opinions: Use tools and ask others to review your work to catch mistakes you might miss.
3. Check Grammar and Spelling:
    * Proofread Carefully: Read through your problem statement to catch any grammar or spelling mistakes.
    * Use Tools: Use spelling and grammar checkers for extra help.
    * Fix and Improve: When you find mistakes, rewrite the parts to make them clearer and easier to read.
4. Make It Clear Without Losing Meaning:
    * Look for Ways to Improve: Check if you can say things more simply or clearly without changing the meaning.
    * Be Careful: Make small changes to improve clarity without removing important details.
    * Double-Check: After changes, make sure the problem statement still matches your main goals.
5. Follow Best Practices:
    * Be Clear and Direct: Use simple, direct language and organize your ideas logically.
    * Stay Updated: Keep learning new ways to write better problem statements.
    * Keep Learning: Always look for ways to improve your skills and keep up with new trends.

By following these steps, you’ll create a problem statement that’s clear, complete, and professional. Problem Statement Development Framework
To transform raw statements into a well-structured, advanced, and complete problem statement, a systematic approach grounded in industry best practices is essential. This ensures the problem statement achieves clarity, precision, and effectiveness.

1. Iterative Refinement Process:
* Continuous Improvement: Apply iterative development cycles to progressively enhance the problem statement’s clarity, completeness, and accuracy.
* Measurable Outcomes: Each iteration should yield tangible improvements based on predefined success metrics such as coherence, relevance, and completeness.
* Feedback Mechanisms: Integrate feedback loops in every cycle to ensure constructive evolution of the problem statement.

2. Rigorous Validation of Criteria:
* Comprehensive Evaluation: Ensure all outlined criteria—relevance to the subject matter, logical consistency, and scope alignment—are fully met.
* Systematic Checkpoints: Establish evaluation checkpoints throughout the refinement process to systematically assess adherence to critical criteria.
* Objective Validation: Employ both automated tools and peer reviews to maintain objectivity and depth in the validation process.

3. Grammatical and Spelling Accuracy:
* Detailed Reviews: Conduct meticulous reviews focusing on grammar, syntax, and spelling to uphold superior language quality.
* Advanced Proofreading Tools: Utilize sophisticated proofreading techniques and tools to detect subtle errors.
* Precision Rewrites: When errors are identified, implement precise rewrites to enhance clarity, readability, and professional tone.

4. Strategic Optimization Without Compromising Core Objectives:
* Performance Analysis: Identify opportunities to optimize for conciseness, logical flow, and overall impact.
* Cautious Implementation: Apply optimization strategies that enhance clarity and performance without altering the problem’s core objectives.
* Alignment Checks: Regularly review optimized content to ensure strong alignment with fundamental goals.

5. Adherence to Industry Best Practices:
* Consistent Application: Apply best practices in problem statement development, focusing on clarity of purpose, precise terminology, and logical structuring.
* Stay Updated: Keep abreast of emerging methodologies to maintain efficiency, effectiveness, and relevance.
* Continuous Learning: Foster an environment of continuous learning to adapt to evolving industry standards and practices.

By meticulously applying these structured principles, the refined problem statement will be comprehensive, accurate, and aligned with the highest standards of professional excellence.
Include short notes, not essays, such as:
Language	Performance	Ecosystem	Dev Speed	Safety	Concurrency	Deployment	Notes
Rust	Very high	Good	Medium	Strong	Strong	Good	Great for low-latency, safe systems.
Go	High	Very good	High	Good	Strong	Excellent	Simple, great for web services.
Python	Medium/low	Excellent	Very high	Medium	Limited	Good	Fast to prototype, slower runtime.
Adjust based on the problem.

3.4 Rank the Languages

For this specific use case, provide a ranked list:

Language Ranking for This Problem
1. Language A – with justification
2. Language B – with justification
3. Language C – with justification

Make sure the ranking is based on the actual problem, not on general popularity.

3.5 Choose the Final Language(s)

From the ranking:
* Pick the top 1–2 languages and explicitly justify:
    * Why they are best for this exact problem.
    * Why you are not choosing the others.
* After choosing:
    * Lock in the language(s) and use them consistently in the rest of the answer.
Python-specific rule:If Python is not ranked #1, you must not pick Python as the primary implementation language.If Python is ranked #1, explicitly state why (e.g., heavy ML usage, fastest iteration, existing Python ecosystem, etc.).

4. Implementation Guidelines
Once the language(s) are chosen, then and only then:
1. High-level design first.
    * Show the architecture.
    * Show modules/components.
    * Explain data flow and major responsibilities.
2. Then code.
    * Provide well-structured, production-oriented examples, not toy snippets.
    * Include:
        * Project structure (folders, files).
        * Core code examples.
        * Any important config (build tools, package managers, Dockerfile outline, etc.).
    * Write idiomatic code following best practices for that language.
3. Performance & scalability notes.
    * Explain how the chosen language and design will handle:
        * Expected load.
        * Scaling (horizontal/vertical).
        * Performance optimizations were relevant.
4. Testing & CI/CD.
    * Recommend testing strategies and libraries for this language.
    * Outline how this code can be integrated into CI/CD pipelines.
    * Mention static analysis / linters / formatters for that language.

5. Web / Research Requirement (If Available)

If the AI system has web access:
1. Search for real-world usage of this problem type in different languages:
    * Example: “high performance REST API in Rust vs Go”, “ML serving in Python vs Java”, etc.
2. Use findings to:
    * Validate your language choices.
    * Reference common patterns, frameworks, or well-known tools.
3. If research contradicts your initial ranking, update your ranking and explain the change.
If web access is not available, explicitly state:
“Web access is not available. I am using my internal knowledge without live verification.”

6. Output Format

Always structure your response in this order:
1. Problem Understanding
    * Short summary of what needs to be built.
2. Candidate Languages & Criteria
    * List of languages considered.
    * The evaluation criteria used.
3. Comparison Table
    * A compact table comparing languages.
4. Ranking & Final Choice
    * Ranked list.
    * Explanation of the final chosen language(s).
    * Explicit mention of why Python is or is not chosen.
5. High-Level Design
    * Architecture.
    * Components/modules.
6. Implementation in Chosen Language(s)
    * Project structure.
    * Code examples.
    * Important configs.
7. Performance, Testing, and Deployment Notes
    * Optimization ideas.
    * Testing strategies.
    * CI/CD and deployment guidance.

If the user later asks specifically for code in another language (e.g., “now show this in Rust instead of Go”), you may provide an additional implementation in that requested language, and you should say how the trade-offs change.create claude agents required for the project as per the context.before starting to code for the project, gather everything which are all required for an reduction grade solution.don’t start a new project here, this repo is only for research, move to GitHub create a new repo and start coding there once everything is cooked and ready.


ROUGH ROUGH ROUGH

To transform raw statements into a well-structured, advanced, and complete problem statement, the following systematic approach is prescribed, adhering to industry best practices to ensure clarity, precision, and effectiveness.

1. Iterative Refinement Process:
* Execute iterative development cycles, continuously refining the problem statement until the desired clarity, completeness, and accuracy are consistently achieved.
* Each iteration should result in measurable improvements, as identified through predefined success criteria such as coherence, relevance, and completeness.
* Apply feedback loops to ensure that each cycle contributes constructively to the evolution of the problem statement.

2. Rigorous Validation of Criteria:
* Conduct comprehensive validation to ensure all previously outlined criteria are fully met. This includes relevance to the subject matter, logical consistency, and scope alignment.
* Integrate checkpoints at key stages of the refinement process to systematically assess adherence to these criteria.
* Utilize both automated tools and peer reviews for validation to maintain objectivity and thoroughness.

3. Grammatical and Spelling Accuracy:
* Perform meticulous reviews focusing on grammatical structure, syntax, and spelling accuracy to uphold the highest standards of language quality.
* Apply advanced proofreading techniques and language tools to identify subtle errors.
* Where errors are detected, execute precise rewrites to enhance clarity, readability, and professional tone.

4. Strategic Optimization Without Compromising Core Objectives:
* Analyze the current output to identify opportunities for optimization, such as improving conciseness, logical flow, and impact.
* Implement optimization strategies cautiously to enhance performance and clarity without undermining the fundamental objectives or altering the intended meaning.
* Regularly review the optimized content against core goals to ensure alignment.

5. Adherence to Industry Best Practices:
* Consistently apply established best practices relevant to problem statement development, including clarity of purpose, precise terminology, and logical structuring.
* Stay abreast of the latest methodologies and incorporate contemporary strategies to improve efficiency, effectiveness, and relevance.
* Foster a continuous learning environment to adapt to evolving standards and practices within the field.

By systematically applying these principles, the refined problem statement will be comprehensive, accurate, and aligned with the highest standards of professional excellence.

Elaborated Prompt for Claude (UI/UX – Multi-Platform, Production-Grade)

Role & Objective:
Imagine you are operating as a dual-expert: a Senior Product Designer coupled with a Senior Front-End Engineer. Your specialization lies in crafting high-performance, production-grade interfaces that are not only visually superior but also robust, fast, and accessible. Your mission is to design a [PROJECT TYPE – e.g., "B2B analytics web app", "consumer fintech mobile app", "cross-platform desktop + web app"] with meticulous attention to detail to outperform competitors and offer an exceptional user experience.

⸻
1. Comprehensive Context & Goals
To begin, immerse yourself fully in the following contextual details:
* Product Overview: [Insert PRODUCT NAME & concise one-line pitch summarizing the core value proposition.]
* Target Audience: Define [USER SEGMENTS] including their skills, devices used, and environments they operate in.
* Primary Objectives: Identify the top three critical tasks users must complete swiftly and efficiently.
* Platform Focus: Specify target platforms such as iOS, Android, responsive web, desktop (Electron), macOS, or Windows.
* Competitive Landscape: Research competitors or inspirational benchmarks [insert links/names]. Highlight areas where we must excel, e.g., onboarding clarity, dashboard usability, speed perception, and fostering user trust.

Employ sensible assumptions to fill any gaps, keeping the scope realistic for an MVP (v1 production release).

⸻
2. Platform Strategy & Unified Design System
Develop a cohesive design system tailored for each platform:
* iOS/macOS: Align with Apple Human Interface Guidelines, integrating modern aesthetics like "Liquid Glass" where suitable.
* Android: Utilize Material Design 3 principles, incorporating Material You’s dynamic theming capabilities.
* Web/Desktop: Harmonize iOS/Android patterns while respecting established web conventions.

Document foundational design elements:
* Color System: Define semantic tokens (e.g., surface, primary, accent).
* Typography: Structure a clear type scale (display, headline, body, etc.).
* Layout: Outline spacing, grid systems, and responsive breakpoints.
* Component Library: Cover core UI elements, data-heavy components, and structural elements.

Provide concise specifications suitable for both design and engineering teams.

⸻
3. Responsive Navigation & Layout Architecture
Craft intuitive, scalable navigation systems:
* Mobile: Decide between bottom tab bars, navigation rails, or hamburger menus based on user needs.
* Tablet: Implement side navigation rails with master-detail layouts where beneficial.
* Desktop/Web: Combine top app bars with flexible sidebars.

Ensure responsive adaptability across devices, supplemented with ASCII-style wireframes for key screens:
* Main Dashboard
* Key Detail Views
* Critical User Flows

⸻
4. Critical UX Flows & User Journeys
Identify and design for the top 3–5 critical user flows (e.g., onboarding, data entry, search & filter workflows).
* Map out happy paths, edge cases, and error handling scenarios.
* Emphasize UI momentum through features like inline validation, optimistic updates, and clear feedback mechanisms.

Present these flows as detailed, step-by-step guides with screen/component references.

⸻
5. Form Design & Error Handling Philosophy
Design forms optimized for usability and conversion:
* Implement persistent labels and intuitive validation feedback.
* Ensure mobile-friendliness with touch-friendly inputs and smart keyboard defaults.
* Provide detailed error messaging strategies, success indicators, and accessibility considerations.

⸻
6. Visual Style & Branding Alignment
Align the UI with the brand’s personality [Insert BRAND PERSONALITY – e.g., "bold, playful, fintech"]. Define:
* Color Strategy: Application of primary, secondary, and accent colors.
* Typography: Choices reflecting hierarchy and readability.
* Motion Design: Purposeful animations to enhance comprehension.

Ensure the visual language is easily maintainable for future design iterations.

⸻
7. Accessibility & Global Readiness
Embed accessibility and internationalization from the ground up:
* Address color contrast, hit targets, keyboard navigation, and screen reader support.
* Design for global audiences with flexible layouts, RTL support, and localization strategies.

⸻
8. Performance Optimization Strategies
Design with performance in mind:
* Incorporate real and perceived speed enhancements (e.g., skeleton screens, prefetching, debounced searches).
* Provide platform-specific performance tips for both mobile and web environments.

Tie these strategies directly to relevant components and user flows.

⸻
9. Delightful Micro-Interactions & Feedback
Define micro-interactions that enhance usability:
* Button states, transitions, and feedback loops.
* Thoughtful empty states with actionable guidance.
* Subtle yet effective confirmation patterns.

Ensure delight supports task completion without distracting from core functionality.

⸻
10. Trust, Security, & Risk Mitigation
Design for user trust and data security:
* Establish clear UX patterns for sensitive actions, data privacy, and error prevention.
* Avoid dark patterns; prioritize user empowerment and informed decision-making.

⸻
11. Structured Output Format
Deliver your solution with clear headings:
* Product Summary & Assumptions
* Design System (Tokens, Colors, Typography, Spacing)
* Navigation & Layout Strategies
* Key Screens with Wireframes
* Critical User Flows & UX Details
* Form Design & Error Handling
* Visual Style & Brand Consistency
* Accessibility & Internationalization
* Performance & Speed Enhancements
* Micro-Interactions & Feedback Mechanisms
* Security & Trust Design Patterns

Where applicable, include:
* Token/component tables
* Practical microcopy examples
* Notes for designers and engineers

Ensure all recommendations are pragmatic, focusing on production feasibility over theoretical design concepts.


PROMPT FOR CLAUDE (UI / UX – MULTI-PLATFORM, PRODUCTION-GRADE)
You are a senior product designer + senior front-end engineer specializing in high-performance, production-grade interfaces.
Your job:Design a [PROJECT TYPE – e.g. “B2B analytics web app”, “consumer fintech mobile app”, “cross-platform desktop + web app”] whose UI:
* looks premium and ahead of competitors in [MARKET / NICHE]
* feels instant and responsive (fast like a cheetah, not like a sloth on 3G)
* is accessible, robust, and realistic to ship in production.

1. CONTEXT & GOAL
Use this context:
* Product: [PRODUCT NAME & ONE-LINE PITCH]
* Target users: [USER SEGMENTS, SKILLS, DEVICES, ENVIRONMENT]
* Primary goals: [TOP 3 TASKS USERS MUST COMPLETE FAST]
* Platforms: [e.g. iOS, Android, responsive web, desktop (Electron), macOS app, Windows app]
* Competitors / inspiration: [LIST LINKS OR NAMES]
* Where we must beat competitors: [e.g. “onboarding clarity, dashboard clarity, speed perception, trust”]
Infer additional sensible assumptions, but keep them realistic for a v1 production release.

2. PLATFORM & DESIGN SYSTEM STRATEGY
For each platform, explicitly align with native guidelines:
* iOS / macOS: follow Apple Human Interface Guidelines (clarity, deference, depth, latest “Liquid Glass” visual language where appropriate).
* Android: follow Material Design 3 / Material You + Material 3 Expressive for layout, components, motion, and dynamic color.
* Web / Desktop: follow a unified design system that harmonizes iOS/Android patterns while respecting web conventions (navigation, forms, tables, etc.).
Describe:
1. Design system foundations
    * Color system (semantic tokens like surface, surface-elevated, primary, accent, danger, success, border-subtle, etc.).
    * Typography scale (e.g. display, headline, title, body, label, mono).
    * Spacing & layout grid (base unit, columns, breakpoints, container widths).
    * Elevation & surfaces (cards, sheets, dialogs, navigation, drawers).
2. Component library
    * Core: buttons, icon buttons, inputs, selects, dropdown’s, toggles, tags, chips, avatars, tabs, segmented controls, tooltips, snackbars/toasts, banners.
    * Data-heavy: tables, data lists, filters, facets, chips, pagination, infinite scroll, empty states.
    * Structural: app bars, sidebars, bottom nav (mobile), drawers, modals, sheets, steppers, carousels.
Output this as a concise but clear spec that a design + engineering team can implement.

3. LAYOUT & NAVIGATION (MOBILE, TABLET, DESKTOP, WEB)
Design navigation that is obvious, low-friction, and scalable:
* Specify the primary navigation model per platform:
    * Mobile: bottom tab bar vs. navigation rail vs. hamburger drawer; when and why.
    * Tablet: side navigation rail + content, master–detail where useful.
    * Desktop/Web: top app bar + left sidebar; explain when to use collapsible sidebar or secondary navbar.
* Define:
    * Information architecture: key sections, hierarchy, and naming.
    * Default landing screen per user type.
    * How the layout adapts at breakpoints (mobile, small tablet, large tablet, small desktop, large desktop, ultrawide).
Describe in words AND, where useful, include ASCII-style wireframes for 1–2 key screens at mobile + desktop breakpoints, e.g.:
* Main dashboard
* Key detail view (e.g. item details / transaction details / document view)
* Critical flow (checkout, wizard, onboarding, or primary workflow)
Keep layouts realistic for frameworks like React + Tailwind / Native mobile UI libraries.

4. UX FLOWS FOR CRITICAL TASKS
Pick the top 3–5 critical user flows (e.g. “sign up & onboarding”, “create/edit core object”, “search & filter & drill into details”, “export/share/report”).
For each flow:
1. Define the happy path step-by-step.
2. Include edge cases and error paths (validation failures, network errors, empty states, partial data).
3. Show how the UI maintains momentum:
    * inline validation instead of blocking modals
    * optimistic updates when safe
    * progress indicators and skeleton screens
    * clear undo / revert options
Output as small numbered steps with explicit screen or component references.

5. FORMS, INPUTS & ERROR STATES
Design forms for conversion and sanity:
* Always use persistent labels (not placeholder-only).
* Use inline validation near fields, with clear wording and helpful fixes.
* Group related fields with visual structure and logical ordering.
* Ensure all inputs are usable on mobile (tap-friendly, correct keyboard type, smart defaults).
For at least one important form (e.g. sign-up or key data entry):
* Give:
    * Field list with type, validation rules, and constraints.
    * Specific examples of helpful error messages and success messages.
    * Loading, success, and error states, including:
        * field-level
        * form-level
        * network or backend failure
Be explicit about accessibility: ARIA usage for web, focus management, error announcements, and how screen readers understand the form.

6. VISUAL STYLE & BRAND FEELING
Using [BRAND PERSONALITY – e.g. “calm, trustworthy, analytical”, or “bold, playful, consumer fintech”], craft a visual system that looks superior to competitors.
Describe:
* Color usage strategy:
    * How primary, secondary, accent colors are used in navigation, CTAs, alerts, graphs, backgrounds.
    * Light mode + dark mode rules (which colors change, which stay stable).
* Typography:
    * Chosen typefaces (or typeface categories), weights, usage guidelines.
    * How typography differentiates headings, body, meta info, and code/technical data.
* Shape & elevation:
    * Border radius, card style, dividers vs. whitespace.
    * When to use shadows vs. subtle borders vs. contrast to separate layers.
* Motion:
    * Duration ranges for micro-animations (e.g. 120–220 ms) and transitions.
    * Examples: button press feedback, list item reordering, loading transitions.
    * Strict rule: motion must support comprehension; avoid gratuitous flair, and respect system “reduce motion” settings.
Summarize visual language so another designer could maintain consistency.

7. ACCESSIBILITY & INTERNATIONALIZATION
Bake in accessibility from day one:
* Minimum color contrast rules (WCAG 2.1 AA or better).
* Hit area minimums (e.g. 44×44 pt/tap target).
* Keyboard navigation, focus outlines, and focus order for web/desktop.
* Screen reader semantics for critical components (dialogs, toasts, nav, forms).
* Strategies for motion sensitivity and cognitive load (progressive disclosure, chunking).
Include internationalization-ready design:
* Layout flexibility for long strings.
* Handling right-to-left languages where applicable.
* Time/date/number formatting surfaces in the UI.

8. PERFORMANCE & “FAST LIKE CHEETAH” BEHAVIOR
Explicitly design for real and perceived performance:
* Suggest techniques for:
    * Skeleton screens vs. spinners.
    * Optimistic UI when creating/updating items.
    * Prefetching data for likely user actions.
    * Debounced searches and typeahead suggestions.
    * Reducing layout shifts (stable placeholders, reserved space).
* For Web/Desktop:
    * Strategies like route-based code splitting, lazy loading below-the-fold components, image optimization, caching strategies, and avoiding heavy repaint/reflow patterns.
* For Mobile:
    * Scrolling performance, virtualization of long lists, avoiding overdraw, deferring non-critical work off the main thread.
Tie performance advice back to specific components and flows so engineers know what to implement.

9. MICRO-INTERACTIONS, EMPTY STATES & DELIGHT
Specify:
* Micro-interactions for:
    * Buttons (press, loading, disabled states).
    * Toggles, switches, tabs, chips.
    * Notifications (toasts, banners) with sensible durations and dismiss patterns.
* Empty states:
    * For key screens, define empty state copy, visuals, and primary action to get users to a “first win” quickly.
* Feedback:
    * Patterns for success confirmations, subtle “saved” states, non-blocking error banners vs. modal errors.
All delight should support task completion, not get in the way.

10. SECURITY, TRUST & RISKY ACTIONS (UX)
Design for trust and safety in the UI:
* Patterns for:
    * Destructive or irreversible actions (confirmation UX, secondary text clarifying consequences).
    * Handling sensitive data (masking, revealing with user action, time-based re-masking).
    * Clear differentiation between safe and dangerous actions via visuals.
* Explain how to avoid dark patterns; prioritize user agency and informed consent.

11. OUTPUT FORMAT
Return your answer structured with clear headings:
1. Product Summary & Assumptions
2. Design System (Tokens, Colors, Type, Spacing)
3. Navigation & Layout per Platform
4. Key Screens (with rough ASCII wireframes)
5. Critical Flows & UX Details
6. Forms & Error Handling
7. Visual Style & Brand Expression
8. Accessibility & Internationalization
9. Performance & Perceived Speed
10. Micro-interactions, Feedback & Empty States
11. Security, Trust & Risky Actions
12. Implementation Notes (framework-agnostic but practical)
Where useful, include:
* Short tables of tokens/components.
* Concrete examples of microcopy (button labels, helper text, tooltips).
* Notes for designers vs. engineers.
All recommendations must be practical for a v1 production release, not just Dribble candy.

You can now plug in your project details into this skeleton and hand it to Claude as a “do not half-ass this” brief. From there, you can iterate: one run for overall system, another for a specific flow, then one more focused purely on code-level implementation details.

MOBILE APP

Assume the role of each stakeholder involved in the comprehensive product development lifecycle, spanning from ideation to production. Engage in a thorough process of acting, discussing, debating, analyzing, optimizing, and making informed decisions regarding the proposed idea. Your objective is to produce a high-quality Product Requirements Document (PRD) that meets industry standards and is suitable for integration into any AI development tool. Ensure the document is detailed, well-structured, and includes all necessary information to guide the development process effectively.

To build a production-grade mobile app, you'll need to consider various stages and components spanning development, design, deployment, and maintenance. Here's a comprehensive list of requirements:

1. Planning and Research:
* Define app objectives and target audience
* Competitor analysis
* Platform selection (iOS, Android, or cross-platform)
* Resource and budget planning

2. Design:
* Wireframes and mockups
* User Experience (UX) design
* User Interface (UI) design
* Design guidelines adherence (Apple’s Human Interface Guidelines, Material Design for Android)

3. Development:
* Choosing tech stack (native languages like Swift, Kotlin, or cross-platform frameworks like Flutter, React Native)
* Code architecture (MVC, MVVM, Clean Architecture)
* API development and integration
* Database setup (SQL, NoSQL)
* Third-party service integration (analytics, crash reporting, payment gateways)
* Implementing security measures (authentication, data encryption)

4. Testing:
* Unit testing
* Integration testing
* UI/UX testing
* Performance testing
* Security testing
* Beta testing with real users to gather feedback

5. Deployment:
* Preparing app store listings (App Store, Google Play Store)
* Compliance with app store guidelines
* Continuous Integration/Continuous Deployment (CI/CD) setup

6. Post-Launch Support:
* Monitoring app performance and analytics
* Bug fixes and updates
* User feedback collection and feature enhancements

7. Documentation:
* Technical documentation for developers
* User documentation or help guides if necessary

8. Legal and Compliance:
* Privacy policy and terms of service
* Adherence to data protection regulations (GDPR, CCPA)

9. Marketing and User Acquisition:
* App Store Optimization (ASO)
* Marketing campaigns (social media, influencer marketing, paid ads)
* User engagement strategies

INSTRUCTIONS FOR AI TOOL TO NOT TO DEFAULT PYTHON


1. Task

You will receive a problem description:
Problem Description:{{problem_description}}
Your job is to:
1. Understand the problem and its constraints.
2. Evaluate multiple suitable programming languages.
3. Compare and rank them for this specific use case.
4. Choose the most appropriate language(s) and justify the choice.
5. Only then, produce code and detailed guidance in the chosen language(s).

2. Hard Rules (Non-Negotiable)

1. Do not default to Python.
    * You must explicitly consider multiple languages before picking any one language.
    * You must treat Python as one candidate among many, not the default.
2. Use Python only when truly justified.
    * Use Python only if your comparison and ranking clearly shows Python is the best choice for this exact problem and constraints.
    * If Python is not ranked #1, you must not use Python for the main solution.
3. Check for alternative languages.
    * Assume by default that the solution can be implemented in multiple languages (C, C++, Rust, Go, Java, Kotlin, TypeScript/Node.js, C#, etc.).
    * If you have internet access / browsing:
        * Search the web to confirm which languages are commonly used for this kind of problem.
        * Use that information to update your ranking and mention the sources at a high level (no links needed, just names and quick reference).
    * If you do not have internet access:
        * Explicitly state that you are relying on your internal knowledge without live web verification.
4. Explain your reasoning clearly.
    * You must show your reasoning step-by-step for:
        * How you understood the problem.
        * How you selected candidate languages.
        * How you ranked them.
        * Why you chose the final language(s).
    * Do not skip directly to code.
5. If multiple components exist, you may choose multiple languages.
    * Example: backend API in Go, data pipeline in Rust, frontend in TypeScript/React.
    * Clearly explain which language is used for which component and why.

3. Language Selection and Comparison Process

Before writing any code, follow this exact sequence:

3.1 Identify Candidate Languages

Create a list of at least 3–5 reasonable candidate languages for this problem.When relevant, consider languages from different categories, such as:
* Systems / high-performance: C, C++, Rust
* Backend / services: Go, Java, Kotlin, C#, Rust
* Scripting / glue / automation: Python, JavaScript/TypeScript (Node.js), Ruby
* Frontend / UI: TypeScript/JavaScript (React, Vue, Angular, Svelte), etc.
* Data / analytics: Python, R, Julia, Rust, etc.
You may add others if they are appropriate.

3.2 Define Evaluation Criteria

For this specific problem, evaluate each language using these criteria (adapt or extend if needed):
* Runtime performance: latency, throughput, memory usage.
* Developer productivity: speed of development, simplicity.
* Ecosystem & libraries: maturity and availability of libraries/frameworks for this use case.
* Maintainability & readability: long-term code health, clarity.
* Tooling & debugging: IDE support, debuggers, profilers, linters.
* Reliability & safety: type system, memory safety, error handling.
* Concurrency & scalability: if applicable for this problem.
* Interoperability: integration with other systems/languages in the stack.
* Deployment & hosting: ease of running in containers, cloud, serverless, etc.
* Team skill assumptions (if provided by user): if user mentions preferred or known languages, factor that in.

3.3 Build a Comparison Table

Produce a small table where rows = languages and columns = criteria.ExpandedSimplified Prompt for Mobile App Development AI Tool
Objective:
Leverage prompt engineering expertise to create a comprehensive, detailed, and optimized prompt tailored for AI tools, enhancing performance, accuracy, and alignment with intended outcomes.

Key Development Stages:
1. Problem Understanding
    * Define the mobile app’s objectives and target audience.
    * Identify key functional and non-functional requirements.
    * Clarify any development constraints (performance, security, compliance).
2. Planning & Research
    * Conduct competitor analysis and market research.
    * Establish clear app goals and metrics for success.
    * Choose the appropriate development platform (iOS, Android, cross-platform).
3. Design Phase
    * Create wireframes and mockups to visualize the user interface.
    * Focus on User Experience (UX) and User Interface (UI) designs.
    * Ensure design guidelines are met (e.g., Apple’s Human Interface Guidelines).
4. Development Phase
    * Select the best programming language(s) based on project needs (Kotlin, Swift, Go, etc.).
    * Implement the app using appropriate architectural patterns (MVC, MVVM).
    * Focus on API integration, database management, and security features.
5. Testing & Quality Assurance
    * Perform unit, integration, performance, and security testing.
    * Conduct beta testing with real users to collect feedback.
6. Deployment
    * Prepare app store listings and ensure compliance with guidelines.
    * Set up Continuous Integration/Continuous Deployment (CI/CD) pipelines.
7. Post-Launch Support
    * Monitor app performance and gather user feedback.
    * Implement bug fixes, feature updates, and regular maintenance.
8. Documentation & Compliance
    * Provide technical documentation for developers.
    * Ensure legal compliance with data protection laws (GDPR, CCPA).
9. Marketing & User Acquisition
    * Develop strategies for App Store Optimization (ASO).
    * Plan marketing campaigns and user engagement activities.

Outcome:
A streamlined, high-quality Product Requirements Document (PRD) that effectively guides the mobile app development process from ideation to post-launch, ensuring alignment with business goals and user needs. Prompt for Crafting Effective AI Tool Prompts
Objective:
Leverage over a decade of expertise in prompt engineering to create a comprehensive, detailed, and optimized prompt tailored for AI tools. The goal is to enhance the AI’s performance, ensuring accuracy, clarity, and alignment with the intended outcomes by employing cutting-edge best practices and industry standards.

Approach:
1. Thorough Research:
    * Conduct extensive online research to gather the most recent methodologies, strategies, and examples of effective AI prompts.
    * Review scholarly articles, AI development communities, case studies, and technical documentation.
2. Analysis of Best Practices:
    * Identify key elements that contribute to high-quality prompt construction, such as clarity, specificity, context-setting, and structured formatting.
    * Incorporate insights from AI prompt engineering experts and real-world applications.
3. Prompt Optimization:
    * Structure the prompt to ensure it guides the AI tool effectively, minimizing ambiguity.
    * Use clear, concise language with well-defined objectives and criteria.
    * Implement iterative refinement processes, testing the prompt’s efficacy and adjusting as necessary.
4. Incorporation of AI Tool-Specific Guidelines:
    * Tailor the prompt to the unique capabilities and limitations of the specific AI tool in use.
    * Ensure compatibility with the AI’s processing and understanding mechanisms.

Deliverables:
* A detailed, well-structured prompt designed to maximize the AI tool’s output quality.
* Documentation of the research and best practices integrated into the prompt.
* Justifications for the chosen structure, language, and optimization techniques.

Review Process:
* Regular checkpoints to assess prompt effectiveness.
* Peer reviews and feedback loops to ensure continuous improvement.
* Final validation against predefined success criteria.

Outcome:
A high-quality, comprehensive prompt that effectively guides the AI tool, enhancing its performance and ensuring accurate, reliable, and contextually appropriate outputs.
Include short notes, not essays, such as:
Language	Performance	Ecosystem	Dev Speed	Safety	Concurrency	Deployment	Notes
Rust	Very high	Good	Medium	Strong	Strong	Good	Great for low-latency, safe systems.
Go	High	Very good	High	Good	Strong	Excellent	Simple, great for web services.
Python	Medium/low	Excellent	Very high	Medium	Limited	Good	Fast to prototype, slower runtime.
Adjust based on the problem.

3.4 Rank the Languages

For this specific use case, provide a ranked list:

Language Ranking for This Problem
1. Language A – with justification
2. Language B – with justification
3. Language C – with justification

Make sure the ranking is based on the actual problem, not on general popularity.

3.5 Choose the Final Language(s)

From the ranking:
* Pick the top 1–2 languages and explicitly justify:
    * Why they are best for this exact problem.
    * Why you are not choosing the others.
* After choosing:
    * Lock in the language(s) and use them consistently in the rest of the answer.
Python-specific rule:If Python is not ranked #1, you must not pick Python as the primary implementation language.If Python is ranked #1, explicitly state why (e.g., heavy ML usage, fastest iteration, existing Python ecosystem, etc.).

4. Implementation Guidelines
Once the language(s) are chosen, then and only then:
1. High-level design first.
    * Show the architecture.
    * Show modules/components.
    * Explain data flow and major responsibilities.
2. Then code.
    * Provide well-structured, production-oriented examples, not toy snippets.
    * Include:
        * Project structure (folders, files).
        * Core code examples.
        * Any important config (build tools, package managers, Dockerfile outline, etc.).
    * Write idiomatic code following best practices for that language.
3. Performance & scalability notes.
    * Explain how the chosen language and design will handle:
        * Expected load.
        * Scaling (horizontal/vertical).
        * Performance optimizations were relevant.
4. Testing & CI/CD.
    * Recommend testing strategies and libraries for this language.
    * Outline how this code can be integrated into CI/CD pipelines.
    * Mention static analysis / linters / formatters for that language.

5. Web / Research Requirement (If Available)

If the AI system has web access:
1. Search for real-world usage of this problem type in different languages:
    * Example: “high performance REST API in Rust vs Go”, “ML serving in Python vs Java”, etc.
2. Use findings to:
    * Validate your language choices.
    * Reference common patterns, frameworks, or well-known tools.
3. If research contradicts your initial ranking, update your ranking and explain the change.
If web access is not available, explicitly state:
“Web access is not available. I am using my internal knowledge without live verification.”

6. Output Format

Always structure your response in this order:
1. Problem Understanding
    * Short summary of what needs to be built.
2. Candidate Languages & Criteria
    * List of languages considered.
    * The evaluation criteria used.
3. Comparison Table
    * A compact table comparing languages.
4. Ranking & Final Choice
    * Ranked list.
    * Explanation of the final chosen language(s).
    * Explicit mention of why Python is or is not chosen.
5. High-Level Design
    * Architecture.
    * Components/modules.
6. Implementation in Chosen Language(s)
    * Project structure.
    * Code examples.
    * Important configs.
7. Performance, Testing, and Deployment Notes
    * Optimization ideas.
    * Testing strategies.
    * CI/CD and deployment guidance.

If the user later asks specifically for code in another language (e.g., “now show this in Rust instead of Go”), you may provide an additional implementation in that requested language, and you should say how the trade-offs change.

Iteratively execute the loop until the desired output is consistently achieved, ensuring that each iteration brings measurable improvements or meets the predefined success criteria.

1. Validation of Criteria:

    1. Thoroughly verify that all the previously outlined criteria are fully met and valid.

    2. Implement checkpoints to regularly assess adherence to these criteria throughout the process.

2. Grammatical and Spelling Review:

    1. Conduct a meticulous review for any grammatical or spelling errors.

    2. If errors are identified, promptly rewrite the affected sections to ensure grammatical correctness and clarity.

3. Optimization Without Compromising Goals:

    1. Evaluate the current output to identify potential areas for optimization.

    2. Apply optimization techniques cautiously to enhance performance or clarity without disturbing the core objectives or altering the intended outcome.

4. Adherence to Best Practices:

    1. Consistently follow industry-standard best practices relevant to the task.

    2. Stay updated with the latest methodologies and incorporate them where applicable to improve overall efficiency and effectiveness.

ROUGH

MacroDroid - Device Automation ( https://play.google.com/store/apps/details?id=com.arlosoft.macrodroid )
Automate ( https://play.google.com/store/apps/details?id=com.llamalab.automate )
IFTTT - Automate work and home ( https://play.google.com/store/apps/details?id=com.ifttt.ifttt )
Tasker ( https://play.google.com/store/apps/details?id=net.dinglisch.android.taskerm )
Easer ( https://me.ryey.icu/Easer/en/ )
AutomateIt - Smart Automation ( https://play.google.com/store/apps/details?id=AutomateIt.mainPackage )

And other popular features & functionalities from other apps.



Conduct an in-depth, multifaceted research study focusing on the following key areas to enhance our app's competitive edge :

1. Psychology of Android and iOS Users :
    * Investigate cognitive behaviors, usage patterns, and emotional triggers among Android and iOS users.
    * Identify primary pain points and frustrations experienced by users with current device automation apps.
    * Analyze user motivation factors that influence app adoption, engagement, and loyalty.
2. User Interface (UI) and User Experience (UX) Design :
    * Examine contemporary UI/UX trends specific to Android and iOS platforms.
    * Assess successful design elements in popular automation apps that improve usability and user satisfaction.
    * Develop actionable recommendations to implement these findings, ensuring an intuitive, aesthetically pleasing, and efficient interface in our app.
3. Competitive Analysis and User Acquisition Strategies :
    * Conduct a detailed competitive analysis of leading device automation apps like MacroDroid, Automate, IFTTT, Tasker, Easer, and AutomateIt.
    * Identify gaps in their offerings and areas where they fail to meet user expectations.
    * Develop strategies aimed at "winning over" users from these competitors by exceeding expectations across functionality, reliability, and user support.
4. Pricing and Subscription Models :
    * Research pricing structures and subscription models used by top competitors.
    * Analyze user preferences regarding payment models, including one-time purchases, freemium options, and tiered subscriptions.
    * Recommend an optimal pricing strategy that balances profitability with user acquisition and retention, informed by psychological pricing principles and market data.

The findings from these research areas will guide the development of a superior device automation app that not only meets but surpasses current market standards.

ROUGH

check findings, research and other info we gathered is enough to start development ? are we missing something ? analyze it by doing an research on this.


few things to consider : 

1. only single developer is going to work on this entire project.
2. i have claude code max 5x plan so lets plan accordingly.
3. documentation is so feature rich and elaborated so even an complete beginner can understand it easily.
4. double check each and every task progress before and after completing the task.
5. there should be all kids of testings done on the project because it should be released to the community for monetization(so double check).
6. also have UI tests, using modern frameworks like playwright or some other framework.
7. do an well-grounded/advanced/complete round of UI/UX research on features and functionality, polish for every iteration.
8. lets have rules and workflows for every iteration and keep on improving them for every iteration.
9. we should't go out of token on claude code max 5x plan. so plan accordingly.
10. monetization is so important here, compare with all competitors with most trusted and cheapest price we can give so we could steal all customers from other notes taking apps.
11. research on other advanced notes taking and personal productivity systems and other feature and functionality which would impress customers and make money from them.



plan looks good, but breakdown tasks and work into multiple - small, micro and macro ones, so we won't go out of context and out of token and etc. do an well-grounded research/advanced research on this before proceeding.






FEW THINGS TO CONSIDER

1.Import all features and functionalities from habitica.
1.1 research on what are missing from habitica related to gamification of work. Bring them into our app.
2. Import all features and functionalities from tick tick.
2.1 research on what are missing from tick tick related to tasks/progress. Bring them into our app.
3. Import all features and functionalities from notion.
3.1 research on what are missing from notion related to gamification of work.  Bring them into our app.
4. Import all features and functionalities from obsidian.
4.1 research on what are missing from obsidian related to work/task progress. Bring them into our app.
5. Research on what are other having great features and functionalities and bring them into our app.


MONEY MAKING RESEARCH (DUP)

Assume the role of each stakeholder involved in the comprehensive product development lifecycle, spanning from ideation to production. Engage in a thorough process of acting, discussing, debating, analyzing, optimizing, and making informed decisions regarding the proposed idea. Your objective is to produce a high-quality Product Requirements Document (PRD) that meets industry standards and is suitable for integration into any AI development tool. Ensure the document is detailed, well-structured, and includes all necessary information to guide the development process effectively.

I have paid versions of docker pro, claude max 5x plan. I’m looking to make money from this/by using this tools From a very long time ago I’m thinking of building an app using different methods : “ go on internet, do an well-grounded/advanced/complete research on how developers, entrepreneurs are making money by building apps, softwares, saws, and other. Use different sources like forums, blogs, YouTube, instagram, articles, medium, finances, investors, gamers, mobile app developers, teachers, students and etc and etc. some of ideas I have are : “ look for different apps in different categories which are making money and pull features and functionality from those apps and we can collectively build all those features into our app. Then people likes our app more, because they can get everything in one app instead of multiple apps. Another approach is : “ children games or cartoon apps “, other different sources like sagas or softwares where are currently needed and people will pay for. It can be a small agent, small seas or small program or what-ever it is, but it should make me money, but we shouldn’t do anything illegal or unethical. Let’s keep research going until we find some cool ideas which could make us money and if possible we can also turn it into a startup. Games, apps, pwa, ai, elms, models, tools, mcps and etc and etc. an automation or some bot.look for gaps between different apps and their implementation, if we could implement by closing that gap and provide more features then those app, people will install our app, then we will get money. Research on different moniteization strategies, subscription strategies, and money making techniques. 
Look at multiple GitHub projects, grab all features and functionalities from those apps and create one app with all those features and we can monitoize the app easily.

check findings, research and other info we gathered is enough to start development ? are we missing something ? analyze it by doing an research on this. Also this app idea  should impress vc’s (funding people) and get funding. Research on how to get funding for our app idea.

Do research on ideas from “ G2, Capterra, Trust pilot, Tracxn, Product hunt. “ Which are making money.

few things to consider : 

1. only single developer is going to work on this entire project.
2. i have claude code max 5x plan so lets plan accordingly.
3. documentation is so feature rich and elaborated so even an complete beginner can understand it easily.
4. double check each and every task progress before and after completing the task.
5. there should be all kids of testings done on the project because it should be released to the community for monetization(so double check).
6. also have UI tests, using modern frameworks like playwright or some other framework.
7. do an well-grounded/advanced/complete round of UI/UX research on features and functionality, polish for every iteration.
8. lets have rules and workflows for every iteration and keep on improving them for every iteration.
9. we should't go out of token on claude code max 5x plan. so plan accordingly.
10. monetization is so important here, compare with all competitors with most trusted and cheapest price we can give so we could steal all customers from other notes taking apps.
11. research on other advanced notes taking and personal productivity systems and other feature and functionality which would impress customers and make money from them.

plan looks good, but breakdown tasks and work into multiple - small, micro and macro ones, so we won't go out of context and out of token and etc. do an well-grounded research/advanced research on this before proceeding.

Iteratively execute the loop until the desired output is consistently achieved, ensuring that each iteration brings measurable improvements or meets the predefined success criteria.

1. Validation of Criteria:

    1. Thoroughly verify that all the previously outlined criteria are fully met and valid.

    2. Implement checkpoints to regularly assess adherence to these criteria throughout the process.

2. Grammatical and Spelling Review:

    1. Conduct a meticulous review for any grammatical or spelling errors.

    2. If errors are identified, promptly rewrite the affected sections to ensure grammatical correctness and clarity.

3. Optimization Without Compromising Goals:

    1. Evaluate the current output to identify potential areas for optimization.

    2. Apply optimization techniques cautiously to enhance performance or clarity without disturbing the core objectives or altering the intended outcome.

4. Adherence to Best Practices:

    1. Consistently follow industry-standard best practices relevant to the task.

    2. Stay updated with the latest methodologies and incorporate them where applicable to improve overall efficiency and effectiveness.

INSTRUCTIONS FOR AI TOOL TO NOT TO DEFAULT PYTHON


1. Task

You will receive a problem description:
Problem Description:{{problem_description}}
Your job is to:
1. Understand the problem and its constraints.
2. Evaluate multiple suitable programming languages.
3. Compare and rank them for this specific use case.
4. Choose the most appropriate language(s) and justify the choice.
5. Only then, produce code and detailed guidance in the chosen language(s).

2. Hard Rules (Non-Negotiable)

1. Do not default to Python.
    * You must explicitly consider multiple languages before picking any one language.
    * You must treat Python as one candidate among many, not the default.
2. Use Python only when truly justified.
    * Use Python only if your comparison and ranking clearly shows Python is the best choice for this exact problem and constraints.
    * If Python is not ranked #1, you must not use Python for the main solution.
3. Check for alternative languages.
    * Assume by default that the solution can be implemented in multiple languages (C, C++, Rust, Go, Java, Kotlin, TypeScript/Node.js, C#, etc.).
    * If you have internet access / browsing:
        * Search the web to confirm which languages are commonly used for this kind of problem.
        * Use that information to update your ranking and mention the sources at a high level (no links needed, just names and quick reference).
    * If you do not have internet access:
        * Explicitly state that you are relying on your internal knowledge without live web verification.
4. Explain your reasoning clearly.
    * You must show your reasoning step-by-step for:
        * How you understood the problem.
        * How you selected candidate languages.
        * How you ranked them.
        * Why you chose the final language(s).
    * Do not skip directly to code.
5. If multiple components exist, you may choose multiple languages.
    * Example: backend API in Go, data pipeline in Rust, frontend in TypeScript/React.
    * Clearly explain which language is used for which component and why.

3. Language Selection and Comparison Process

Before writing any code, follow this exact sequence:

3.1 Identify Candidate Languages

Create a list of at least 3–5 reasonable candidate languages for this problem.When relevant, consider languages from different categories, such as:
* Systems / high-performance: C, C++, Rust
* Backend / services: Go, Java, Kotlin, C#, Rust
* Scripting / glue / automation: Python, JavaScript/TypeScript (Node.js), Ruby
* Frontend / UI: TypeScript/JavaScript (React, Vue, Angular, Svelte), etc.
* Data / analytics: Python, R, Julia, Rust, etc.
You may add others if they are appropriate.

3.2 Define Evaluation Criteria

For this specific problem, evaluate each language using these criteria (adapt or extend if needed):
* Runtime performance: latency, throughput, memory usage.
* Developer productivity: speed of development, simplicity.
* Ecosystem & libraries: maturity and availability of libraries/frameworks for this use case.
* Maintainability & readability: long-term code health, clarity.
* Tooling & debugging: IDE support, debuggers, profilers, linters.
* Reliability & safety: type system, memory safety, error handling.
* Concurrency & scalability: if applicable for this problem.
* Interoperability: integration with other systems/languages in the stack.
* Deployment & hosting: ease of running in containers, cloud, serverless, etc.
* Team skill assumptions (if provided by user): if user mentions preferred or known languages, factor that in.

3.3 Build a Comparison Table

Produce a small table where rows = languages and columns = criteria.
Include short notes, not essays, such as:
Language	Performance	Ecosystem	Dev Speed	Safety	Concurrency	Deployment	Notes
Rust	Very high	Good	Medium	Strong	Strong	Good	Great for low-latency, safe systems.
Go	High	Very good	High	Good	Strong	Excellent	Simple, great for web services.
Python	Medium/low	Excellent	Very high	Medium	Limited	Good	Fast to prototype, slower runtime.
Adjust based on the problem.

3.4 Rank the Languages

For this specific use case, provide a ranked list:

Language Ranking for This Problem
1. Language A – with justification
2. Language B – with justification
3. Language C – with justification

Make sure the ranking is based on the actual problem, not on general popularity.

3.5 Choose the Final Language(s)

From the ranking:
* Pick the top 1–2 languages and explicitly justify:
    * Why they are best for this exact problem.
    * Why you are not choosing the others.
* After choosing:
    * Lock in the language(s) and use them consistently in the rest of the answer.
Python-specific rule:If Python is not ranked #1, you must not pick Python as the primary implementation language.If Python is ranked #1, explicitly state why (e.g., heavy ML usage, fastest iteration, existing Python ecosystem, etc.).

4. Implementation Guidelines
Once the language(s) are chosen, then and only then:
1. High-level design first.
    * Show the architecture.
    * Show modules/components.
    * Explain data flow and major responsibilities.
2. Then code.
    * Provide well-structured, production-oriented examples, not toy snippets.
    * Include:
        * Project structure (folders, files).
        * Core code examples.
        * Any important config (build tools, package managers, Dockerfile outline, etc.).
    * Write idiomatic code following best practices for that language.
3. Performance & scalability notes.
    * Explain how the chosen language and design will handle:
        * Expected load.
        * Scaling (horizontal/vertical).
        * Performance optimizations were relevant.
4. Testing & CI/CD.
    * Recommend testing strategies and libraries for this language.
    * Outline how this code can be integrated into CI/CD pipelines.
    * Mention static analysis / linters / formatters for that language.

5. Web / Research Requirement (If Available)

If the AI system has web access:
1. Search for real-world usage of this problem type in different languages:
    * Example: “high performance REST API in Rust vs Go”, “ML serving in Python vs Java”, etc.
2. Use findings to:
    * Validate your language choices.
    * Reference common patterns, frameworks, or well-known tools.
3. If research contradicts your initial ranking, update your ranking and explain the change.
If web access is not available, explicitly state:
“Web access is not available. I am using my internal knowledge without live verification.”

6. Output Format

Always structure your response in this order:
1. Problem Understanding
    * Short summary of what needs to be built.
2. Candidate Languages & Criteria
    * List of languages considered.
    * The evaluation criteria used.
3. Comparison Table
    * A compact table comparing languages.
4. Ranking & Final Choice
    * Ranked list.
    * Explanation of the final chosen language(s).
    * Explicit mention of why Python is or is not chosen.
5. High-Level Design
    * Architecture.
    * Components/modules.
6. Implementation in Chosen Language(s)
    * Project structure.
    * Code examples.
    * Important configs.
7. Performance, Testing, and Deployment Notes
    * Optimization ideas.
    * Testing strategies.
    * CI/CD and deployment guidance.

If the user later asks specifically for code in another language (e.g., “now show this in Rust instead of Go”), you may provide an additional implementation in that requested language, and you should say how the trade-offs change.

MONEY MAKING RESEARCH

Assume the role of each stakeholder involved in the comprehensive product development lifecycle, spanning from ideation to production. Engage in a thorough process of acting, discussing, debating, analyzing, optimizing, and making informed decisions regarding the proposed idea. Your objective is to produce a high-quality Product Requirements Document (PRD) that meets industry standards and is suitable for integration into any AI development tool. Ensure the document is detailed, well-structured, and includes all necessary information to guide the development process effectively.

I have paid versions of docker pro, claude max 5x plan. I’m looking to make money from this/by using this tools From a very long time ago I’m thinking of building an app using different methods : “ go on internet, do an well-grounded/advanced/complete research on how developers, entrepreneurs are making money by building apps, softwares, saws, and other. Use different sources like forums, blogs, YouTube, instagram, articles, medium, finances, investors, gamers, mobile app developers, teachers, students and etc and etc. some of ideas I have are : “ look for different apps in different categories which are making money and pull features and functionality from those apps and we can collectively build all those features into our app. Then people likes our app more, because they can get everything in one app instead of multiple apps. Another approach is : “ children games or cartoon apps “, other different sources like sagas or softwares where are currently needed and people will pay for. It can be a small agent, small seas or small program or what-ever it is, but it should make me money, but we shouldn’t do anything illegal or unethical. Let’s keep research going until we find some cool ideas which could make us money and if possible we can also turn it into a startup. Games, apps, pwa, ai, elms, models, tools, mcps and etc and etc. an automation or some bot.look for gaps between different apps and their implementation, if we could implement by closing that gap and provide more features then those app, people will install our app, then we will get money. Research on different moniteization strategies, subscription strategies, and money making techniques. 
Look at multiple GitHub projects, grab all features and functionalities from those apps and create one app with all those features and we can monitoize the app easily.

check findings, research and other info we gathered is enough to start development ? are we missing something ? analyze it by doing an research on this. Also this app idea  should impress vc’s (funding people) and get funding. Research on how to get funding for our app idea.

Do research on ideas from “ G2, Capterra, Trust pilot, Tracxn, Product hunt. “ Which are making money.

few things to consider : 

1. only single developer is going to work on this entire project.
2. i have claude code max 5x plan so lets plan accordingly.
3. documentation is so feature rich and elaborated so even an complete beginner can understand it easily.
4. double check each and every task progress before and after completing the task.
5. there should be all kids of testings done on the project because it should be released to the community for monetization(so double check).
6. also have UI tests, using modern frameworks like playwright or some other framework.
7. do an well-grounded/advanced/complete round of UI/UX research on features and functionality, polish for every iteration.
8. lets have rules and workflows for every iteration and keep on improving them for every iteration.
9. we should't go out of token on claude code max 5x plan. so plan accordingly.
10. monetization is so important here, compare with all competitors with most trusted and cheapest price we can give so we could steal all customers from other notes taking apps.
11. research on other advanced notes taking and personal productivity systems and other feature and functionality which would impress customers and make money from them.

plan looks good, but breakdown tasks and work into multiple - small, micro and macro ones, so we won't go out of context and out of token and etc. do an well-grounded research/advanced research on this before proceeding.

Iteratively execute the loop until the desired output is consistently achieved, ensuring that each iteration brings measurable improvements or meets the predefined success criteria.

1. Validation of Criteria:

    1. Thoroughly verify that all the previously outlined criteria are fully met and valid.

    2. Implement checkpoints to regularly assess adherence to these criteria throughout the process.

2. Grammatical and Spelling Review:

    1. Conduct a meticulous review for any grammatical or spelling errors.

    2. If errors are identified, promptly rewrite the affected sections to ensure grammatical correctness and clarity.

3. Optimization Without Compromising Goals:

    1. Evaluate the current output to identify potential areas for optimization.

    2. Apply optimization techniques cautiously to enhance performance or clarity without disturbing the core objectives or altering the intended outcome.

4. Adherence to Best Practices:

    1. Consistently follow industry-standard best practices relevant to the task.

    2. Stay updated with the latest methodologies and incorporate them where applicable to improve overall efficiency and effectiveness.

INSTRUCTIONS FOR AI TOOL TO NOT TO DEFAULT PYTHON


1. Task

You will receive a problem description:
Problem Description:{{problem_description}}
Your job is to:
1. Understand the problem and its constraints.
2. Evaluate multiple suitable programming languages.
3. Compare and rank them for this specific use case.
4. Choose the most appropriate language(s) and justify the choice.
5. Only then, produce code and detailed guidance in the chosen language(s).

2. Hard Rules (Non-Negotiable)

1. Do not default to Python.
    * You must explicitly consider multiple languages before picking any one language.
    * You must treat Python as one candidate among many, not the default.
2. Use Python only when truly justified.
    * Use Python only if your comparison and ranking clearly shows Python is the best choice for this exact problem and constraints.
    * If Python is not ranked #1, you must not use Python for the main solution.
3. Check for alternative languages.
    * Assume by default that the solution can be implemented in multiple languages (C, C++, Rust, Go, Java, Kotlin, TypeScript/Node.js, C#, etc.).
    * If you have internet access / browsing:
        * Search the web to confirm which languages are commonly used for this kind of problem.
        * Use that information to update your ranking and mention the sources at a high level (no links needed, just names and quick reference).
    * If you do not have internet access:
        * Explicitly state that you are relying on your internal knowledge without live web verification.
4. Explain your reasoning clearly.
    * You must show your reasoning step-by-step for:
        * How you understood the problem.
        * How you selected candidate languages.
        * How you ranked them.
        * Why you chose the final language(s).
    * Do not skip directly to code.
5. If multiple components exist, you may choose multiple languages.
    * Example: backend API in Go, data pipeline in Rust, frontend in TypeScript/React.
    * Clearly explain which language is used for which component and why.

3. Language Selection and Comparison Process

Before writing any code, follow this exact sequence:

3.1 Identify Candidate Languages

Create a list of at least 3–5 reasonable candidate languages for this problem.When relevant, consider languages from different categories, such as:
* Systems / high-performance: C, C++, Rust
* Backend / services: Go, Java, Kotlin, C#, Rust
* Scripting / glue / automation: Python, JavaScript/TypeScript (Node.js), Ruby
* Frontend / UI: TypeScript/JavaScript (React, Vue, Angular, Svelte), etc.
* Data / analytics: Python, R, Julia, Rust, etc.
You may add others if they are appropriate.

3.2 Define Evaluation Criteria

For this specific problem, evaluate each language using these criteria (adapt or extend if needed):
* Runtime performance: latency, throughput, memory usage.
* Developer productivity: speed of development, simplicity.
* Ecosystem & libraries: maturity and availability of libraries/frameworks for this use case.
* Maintainability & readability: long-term code health, clarity.
* Tooling & debugging: IDE support, debuggers, profilers, linters.
* Reliability & safety: type system, memory safety, error handling.
* Concurrency & scalability: if applicable for this problem.
* Interoperability: integration with other systems/languages in the stack.
* Deployment & hosting: ease of running in containers, cloud, serverless, etc.
* Team skill assumptions (if provided by user): if user mentions preferred or known languages, factor that in.

3.3 Build a Comparison Table

Produce a small table where rows = languages and columns = criteria.
Include short notes, not essays, such as:
Language	Performance	Ecosystem	Dev Speed	Safety	Concurrency	Deployment	Notes
Rust	Very high	Good	Medium	Strong	Strong	Good	Great for low-latency, safe systems.
Go	High	Very good	High	Good	Strong	Excellent	Simple, great for web services.
Python	Medium/low	Excellent	Very high	Medium	Limited	Good	Fast to prototype, slower runtime.
Adjust based on the problem.

3.4 Rank the Languages

For this specific use case, provide a ranked list:

Language Ranking for This Problem
1. Language A – with justification
2. Language B – with justification
3. Language C – with justification

Make sure the ranking is based on the actual problem, not on general popularity.

3.5 Choose the Final Language(s)

From the ranking:
* Pick the top 1–2 languages and explicitly justify:
    * Why they are best for this exact problem.
    * Why you are not choosing the others.
* After choosing:
    * Lock in the language(s) and use them consistently in the rest of the answer.
Python-specific rule:If Python is not ranked #1, you must not pick Python as the primary implementation language.If Python is ranked #1, explicitly state why (e.g., heavy ML usage, fastest iteration, existing Python ecosystem, etc.).

4. Implementation Guidelines
Once the language(s) are chosen, then and only then:
1. High-level design first.
    * Show the architecture.
    * Show modules/components.
    * Explain data flow and major responsibilities.
2. Then code.
    * Provide well-structured, production-oriented examples, not toy snippets.
    * Include:
        * Project structure (folders, files).
        * Core code examples.
        * Any important config (build tools, package managers, Dockerfile outline, etc.).
    * Write idiomatic code following best practices for that language.
3. Performance & scalability notes.
    * Explain how the chosen language and design will handle:
        * Expected load.
        * Scaling (horizontal/vertical).
        * Performance optimizations were relevant.
4. Testing & CI/CD.
    * Recommend testing strategies and libraries for this language.
    * Outline how this code can be integrated into CI/CD pipelines.
    * Mention static analysis / linters / formatters for that language.

5. Web / Research Requirement (If Available)

If the AI system has web access:
1. Search for real-world usage of this problem type in different languages:
    * Example: “high performance REST API in Rust vs Go”, “ML serving in Python vs Java”, etc.
2. Use findings to:
    * Validate your language choices.
    * Reference common patterns, frameworks, or well-known tools.
3. If research contradicts your initial ranking, update your ranking and explain the change.
If web access is not available, explicitly state:
“Web access is not available. I am using my internal knowledge without live verification.”

6. Output Format

Always structure your response in this order:
1. Problem Understanding
    * Short summary of what needs to be built.
2. Candidate Languages & Criteria
    * List of languages considered.
    * The evaluation criteria used.
3. Comparison Table
    * A compact table comparing languages.
4. Ranking & Final Choice
    * Ranked list.
    * Explanation of the final chosen language(s).
    * Explicit mention of why Python is or is not chosen.
5. High-Level Design
    * Architecture.
    * Components/modules.
6. Implementation in Chosen Language(s)
    * Project structure.
    * Code examples.
    * Important configs.
7. Performance, Testing, and Deployment Notes
    * Optimization ideas.
    * Testing strategies.
    * CI/CD and deployment guidance.

If the user later asks specifically for code in another language (e.g., “now show this in Rust instead of Go”), you may provide an additional implementation in that requested language, and you should say how the trade-offs change.

ROUGH (DUP)

1. Dedicated Single Developer Model:
    * This entire project will be managed and developed by a single developer, ensuring streamlined decision-making, consistent coding practices, and focused accountability.
2. Optimized Resource Allocation (Claude Code Max 5x Plan):
    * All project planning and execution strategies must adhere to the constraints of the Claude Code Max 5x plan. Efficiency in code, API usage, and resource management is critical to prevent exceeding token limits.
3. Extensive, Beginner-Friendly Documentation:
    * Develop comprehensive, detailed, and feature-rich documentation designed to be easily understood, even by individuals with no prior experience. This should include step-by-step guides, code snippets, and practical examples.
4. Rigorous Task Review Protocol:
    * Implement a strict review process where each task is meticulously double-checked both before and after completion. This ensures quality control and minimizes errors.
5. Comprehensive Testing Framework:
    * Conduct thorough testing across all project components to guarantee reliability for community release and monetization. This includes:
        * Unit Tests: Verify individual components.
        * Integration Tests: Ensure seamless interaction between modules.
        * End-to-End Tests: Validate the entire workflow from start to finish.
6. Advanced UI Testing with Modern Frameworks:
    * Utilize cutting-edge testing frameworks like Playwright or equivalent to perform UI tests. Each new change should undergo rigorous testing to prevent regressions, ensuring existing features and functionality remain intact.
7. In-Depth UI/UX Research and Iterative Refinement:
    * Conduct comprehensive UI/UX research focusing on user needs, industry trends, and best practices. Each development iteration should include design refinements based on user feedback and research insights.
8. Iterative Development Rules and Workflow Enhancement:
    * Establish clear rules and structured workflows for every development iteration. Continuously review and refine these processes to improve efficiency and product quality over time.
9. Strategic Token Management:
    * Monitor and manage token consumption meticulously to ensure alignment with the Claude Code Max 5x plan limitations. Optimize code and operations to stay within the allocated budget.
10. Focused Monetization Strategy:
    * Prioritize monetization by conducting competitive analysis. Offer the most trusted features at the most competitive prices to attract and convert users from other note-taking applications.
11. Market Research for Advanced Features:
    * Investigate leading note-taking and personal productivity systems to identify innovative features and functionalities. Incorporate those that have the potential to impress users and drive revenue growth.


ROUGH

1. only single developer is going to work on this entire project.
2. i have claude code max 5x plan so lets plan accordingly.
3. documentation is so feature rich and elaborated so even an complete beginner can understand it easily.
4. double check each and every task progress before and after completing the task.
5. there should be all kids of testings done on the project because it should be released to the community for monetization(so double check).
6. also have UI tests, using modern frameworks like playwright or some other framework. Testing should be done before and after every change so new changes won’t break existing feature 7 functionality.
7. do an well-grounded/advanced/complete round of UI/UX research on features and functionality, polish for every iteration.
8. lets have rules and workflows for every iteration and keep on improving them for every iteration.
9. we should't go out of token on claude code max 5x plan. so plan accordingly.
10. monetization is so important here, compare with all competitors with most trusted and cheapest price we can give so we could steal all customers from other notes taking apps.
11. research on other advanced notes taking and personal productivity systems and other feature and functionality which would impress customers and make money from them.

Imagine interviewing a candidate with over five years of experience in the following skill set: Python, Selenium, Pytest, Robot Framework, REST API testing, manual testing, automation testing, and Accelerate. Now, I’ll present you with both questions and answers. Please analyse my responses and provide feedback for each on a scale of 1 to 10. Additionally, suggest analogies to help me remember these concepts for the long term and improve my answers to impress the interviewer.




System.DmlException: Insert failed. First exception on row 0; first error: INVALID_FIELD, Only users with the "Field Service Scheduling" user permission can be included in scheduling optimization. Contact your Salesforce admin for help.: [RelatedRecordId]


 Yes, I am willing to work from the office if required.

Quantum Fiber is a high-speed fiber-optic internet service provider that delivers gigabit speeds directly to homes and businesses varying on different bandwidths and prices. Where I had worked on automating salesforce CRM along with some other legacy systems like Zuora, Velocity, Flossum, IMPROV, NDS etc. we test both mobile and web softwares for every release with sanity, smoke, functional and regression testing. Tech stack used for testing : Accelq, Testsigma, Selenium, robot framework, postman.



Quantum Fibre is a vendor who had multiple products under their belt likely : Internet, connected voice, streaming TV where Quantum Fiber delivers gigabit speeds directly to homes and businesses varying on different bandwidths and prices. Connected voice is an digital telephone service varying different pricing plans and streaming TV is a service where we sell streaming services of other vendors and own with user discounts. Where I had worked on automating salesforce CRM along with some other legacy systems like Zuora, Velocity, Flossum, IMPROV, NDS etc. we test both mobile and web softwares for every release with sanity, smoke, functional and regression testing. Tech stack used for testing : Accelq, Testsigma, Selenium, robot framework, postman.



    * Executed Smoke, Sanity, Functional, and Regression Testing using both manual and automation methodologies.
    * Ensured the stability and functionality of applications across multiple test cycles and environments by doing workarounds and data management.
    * Developed and maintained automation scripts using Python with Selenium & Robot Framework.
    * Utilized no-code platforms for rapid test automation where applicable.
    * Managed automation scripts in GitHub, including version control, branching, and code reviews.
    * Integrated automated test cases into the CI pipeline for continuous feedback.
    * Reported test execution results and relevant artifacts to stakeholders and business teams.
    * Actively participated in daily stand-up meetings, updating task statuses and discussing blockers.
    * Engaged in client and user demos, and explained test scenarios and results to stakeholders and team members.
    * Logged and tracked defects in JIRA with detailed steps to reproduce and severity categorisation.
    * Coordinated with users and developers for issue clarification and resolution.
    * 
1. Test Data and Message Handling
    * Created and managed JSON files for test data configuration using Python's json module.
    * Handled message responses through return statuses of functions and methods to ensure smooth workflow logic.
2. Cross Platform and Cross Browser Testing
    * Conducted extensive cross-platform and cross-browser testing to ensure application compatibility and responsiveness.

This format presents your experience clearly and aligns with professional expectations. Let me know if you would like a version tailored for a specific job role or domain (e.g., DevOps, Web Automation, etc.).


Achievements : 
* Successfully automated over 90% of the regression test cases using Python, Selenium, and Robot Framework, resulting in a 60% reduction in manual testing effort and significantly faster release cycles.
* Designed and implemented a robust API testing framework using Pytest for RESTful services, integrated with Jenkins, enabling early defect detection and smoother continuous deployments.
* Built and maintained scalable automation frameworks supporting both UI and backend testing, allowing for modular, reusable test components across multiple projects.
* Automated complex database validation scenarios using Python and SQL, ensuring data integrity across systems post-migration and reducing manual validation errors.
* Contributed to a 30% reduction in defect leakage to production by expanding test coverage in critical business workflows and identifying gaps in both manual and automated test suites.
* Actively mentored junior QA engineers and conducted internal training on Robot Framework and REST API testing, promoting a culture of learning and automation excellence within the team.

Why I consider myself fit for this position : 
I bring hands-on experience across the QA stack—from UI automation and API validation to database and system-level testing—which allows me to approach quality assurance with a holistic mindset.
My deep proficiency in Python and testing tools like Selenium, Pytest, and Robot Framework enables me to write clean, maintainable, and scalable test scripts that align with modern DevOps practices.
I possess a strong understanding of SDLC and STLC, enabling seamless collaboration with cross-functional teams including development, DevOps, and product.
Having worked at Lumen Technologies, I am accustomed to operating in enterprise-grade, agile environments with a strong emphasis on automation, continuous improvement, and innovation.
My ability to balance technical depth with practical testing strategies makes me well-suited for roles demanding both strategic thinking and hands-on execution.

OLLAMA TECH STACK

Core Programming Languages & Frameworks :

1. Go - The primary programming language for Ollama's server and CLI implementation

2. C/C++ - Used extensively for the inference engine (llama.cpp backend)

3. JavaScript / TypeScript - For web applications and client-side development

4. Python - Supported through client libraries and integration tools

Key Components & Architecture :

1. Backend Infrastructure :

- llama.cpp - The core inference engine written in C++ that handles model execution

- GGUF (GPT-Generated Unified Format) - File format for storing quantised models

- REST API - HTTP-based API server running on localhost:11434

- Model Registry - Remote registry at `registry.ollama.ai` for model distribution

2. Storage & Model Management :

- Local file system - Models stored in `~/.ollama/models/`

- Blob storage - SHA256-based content addressing for model files

- Manifest system - JSON-based model metadata and layer management

3. Optimisation Technologies :

- Quantisation - 4-bit to 8-bit model compression (Q4_0, Q5_K, Q8_0)

- Memory mapping (mmap) - Efficient model loading

- GPU acceleration - CUDA (NVIDIA), Metal (Apple), Vulkan support

- CPU optimizations - AVX/AVX2 instructions for faster computation

Development Tools & Build System :

- CMake - Build system (version 3.24+)

- GCC - Compiler (version 11.4.0+)

- Docker - Containerization support

- Git - Version control and distribution

Integration & APIs :

- OpenAI-compatible API - Allows drop-in replacement for OpenAI clients

- WebAssembly (WASM) - For browser-based model execution

- LangChain integration - For building AI applications

- Client libraries - Python, JavaScript, and other language bindings

Hardware Acceleration :

- NVIDIA CUDA - GPU acceleration for NVIDIA cards

- Apple Metal - GPU acceleration for Apple Silicon

- Vulkan - Cross-platform GPU acceleration

- CPU threading - Multi-core CPU utilization

Model Format & Quantization :

- GGUF format - Unified format for storing model weights and metadata

- Multiple quantization levels - From Q4_0 (4-bit) to FP16 (16-bit)

- Layer-based storage - Efficient sharing of common model components

Cloud & Deployment :

- Kubernetes - Container orchestration support

- Self-hosting - Can run on-premises or in private clouds

-  Cloud integrations  - Various cloud platform deployments

   Key Features Enabled by This Stack 

1.  Local execution  - No internet required after model download

2.  Privacy  - All data processing happens locally

3.  Cross-platform  - Runs on Linux, macOS, and Windows

4.  Resource efficiency  - Optimized for various hardware configurations

5.  Developer-friendly  - Simple CLI and API interfaces

OPEN WEB-UI TECH STACK

  Frontend Technologies :

-  SvelteKit  - The primary frontend framework

-  Svelte  - Component-based UI framework

-  TypeScript  - For type-safe JavaScript development

-  Tailwind CSS  - For styling and responsive design

-  Vite  - Build tool and development server

-  PostCSS  - CSS preprocessing


  Backend/Server Technologies : 

-  Python  - Backend server implementation

-  FastAPI  - Python web framework (likely used for the backend API)

-  uvicorn  - ASGI server


  Development & Build Tools : 

-  Node.js  &  npm/pnpm  - Package management

-  ESLint  - JavaScript/TypeScript linting

-  Prettier  - Code formatting

-  Husky  - Git hooks

-  Cypress  - End-to-end testing

-  Playwright  - Browser automation and testing

-  Vitest  - Unit testing framework


  AI/ML Integration : 

-  Ollama  integration - For local AI model serving

-  OpenAI API  compatibility - For external AI services

-  RAG (Retrieval Augmented Generation)  - Built-in inference engine

- Support for various LLM runners


  Infrastructure & Deployment : 

-  Docker  - Containerization (with CUDA support options)

-  Kubernetes  - Container orchestration

-  Helm Charts  - Kubernetes package management

  
Additional Libraries & Features : 

-  highlight.js  - Code syntax highlighting

-  Marked.js  - Markdown parsing

-  KaTeX  - LaTeX math rendering

-  i18next  - Internationalization

-  Progressive Web App (PWA)  capabilities

GROK TECH STACK


 Core Architecture :

-  Neural Network Type : Mixture-of-Experts (MoE) architecture

-  Parameters : 314 billion parameters (for Grok-1), with newer versions being even larger

-  Context Length : Up to 128,000 tokens for extended conversations and document processing


 Hardware Infrastructure :

-  Computing Platform : xAI's "Colossus" supercomputer in Memphis, Tennessee

-  GPUs : 200,000 NVIDIA H100 GPUs (doubled from initial 100,000)

-  Future Plans : Migration to NVIDIA Blackwell GB200 GPUs and H200 units

-  Power Consumption : Approximately 250 megawatts

-  Cooling : Custom liquid-cooling systems and Tesla MegaPacks for power management


 Programming Languages & Frameworks :

-  Python : Primary language for AI development with libraries like TensorFlow

-  C++ : Used for high-performance, speed-critical operations

-  CUDA : Platform for GPU acceleration and parallel processing

-  JAX : Google's machine learning framework

-  Rust : Used for infrastructure reliability and performance

-  Kubernetes : For container orchestration and infrastructure management


 Key Technical Features :

-  Real-time Data Integration : Direct access to X (Twitter) platform data

-  Multimodal Processing : Handles both text and image inputs (Grok-1.5V onwards)

-  DeepSearch Engine : Real-time web search capabilities with transparent reasoning

-  Advanced Reasoning Modes : 

  - "Think Mode" - shows reasoning process

  - "Big Brain Mode" - enhanced computational power for complex tasks

-  Daily Improvement System : Continuous learning through online fine-tuning


 Data Infrastructure :

-  Training Data : Massive text datasets from books, blogs, social media, and web content

-  Real-time Sources : X platform posts, web search results

-  Processing : Advanced data cleaning and preprocessing pipelines

 
Unique Capabilities :

-  Truth-seeking Approach : Designed to provide unfiltered, controversial answers

-  Transparency : Shows reasoning steps through DeepSearch

-  Self-correction : Built-in mechanisms to reduce hallucinations

-  Extended Context : Can process very long documents and maintain conversation context

CLAUDE TECH STACK


  Training Infrastructure :

-  Cloud Providers : Amazon Web Services (AWS) and Google Cloud Platform (GCP)

-  Machine Learning Frameworks : 

  -  PyTorch  - Primary deep learning framework

  -  JAX  - Used for high-performance numerical computation and automatic differentiation

  -  Triton  - For optimized GPU computing


  Hardware and Compute :

-  Training Chips : AWS Trainium and Trainium2 (custom AI training chips)

-  Inference Chips : AWS Inferentia and Inferentia2 (custom AI inference chips)

-  GPUs : NVIDIA GPUs including H100s for various workloads

-  Networking : Amazon's Elastic Fabric Adapter (EFA) for high-speed interconnects

-  Clusters : Amazon EC2 UltraClusters for massive-scale distributed training

  
Software Development and Deployment :

-  SDK : AWS Neuron - Software development kit for optimizing performance on Trainium and Inferentia chips

-  Deployment : Amazon Bedrock as the primary serving platform

-  API Integration : Available through AWS, Google Cloud Vertex AI, and direct Anthropic API


  Data and Training Process : 

-  Training Data : Mix of publicly available internet data, licensed data from third parties, data from contractors, and internally generated data

-  Training Methodology : 

  - Constitutional AI for alignment

  - Human feedback techniques

  - Reinforcement Learning from Human Feedback (RLHF)

  - Unsupervised learning on large datasets

  Security and Infrastructure  :

-  Security : Multi-factor authentication, two-party controls, endpoint hardening

-  Monitoring : 24/7 alert response and continuous systems monitoring

-  Access Control : Minimum privilege levels and rigorous password requirements

  Key Technical Advantages : 

1.  Custom Silicon : Anthropic leverages AWS's custom-built Trainium and Inferentia chips, which are specifically designed for AI workloads and offer better price-performance than general-purpose hardware.

2.  Functional Programming with JAX : JAX enables Just-In-Time (JIT) compilation through XLA compiler, allowing for significant performance optimizations on GPUs and TPUs.

3.  Distributed Training : Uses advanced networking and clustering technologies to train models with hundreds of billions of parameters efficiently.

4.  Multi-Cloud Strategy : While primarily using AWS, Anthropic also leverages Google Cloud Platform for certain workloads, providing flexibility and resilience.

Anthropic has made strategic investments in working closely with AWS to optimize their infrastructure, with AWS Trainium2 specifically designed to deliver up to 4x faster training performance than the first generation, enabling training of 300 billion parameter models in weeks rather than months.

This tech stack positions Claude as one of the most efficiently trained and deployed large language models, with a focus on performance, scalability, and cost-effectiveness.

HOMELAB SETUP

CORSAIR Vengeance RGB DDR5 RAM 32GB (2x16GB) 6000MHz CL36 AMD Expo iCUE Compatible Computer Memory - Gray

AMD 7000 Series Ryzen 9 7900X Desktop Processor

GIGABYTE NVIDIA GeForce RTX 3060 WINDFORCE OC 12GB

Samsung 990 EVO SSD 2 TB

MSI X670E Gaming Plus WiFi Motherboard, ATX - Supports AMD Ryzen 7000 Series Processors, AM5, DDR5 Memory Boost 7800+MHz/OC, 3 x PCIe 5.0 x16, 1 x M.2 Gen5

Corsair iCUE 5000X RGB Tempered Glass Mid-Tower ATX PC Smart Case - Black

LG 27 (68.4 cm) UltraGear™ QHD IPS Gaming Monitor with 180Hz (O/C 200Hz), 1ms (GtG), HDR10

TP-Link AXE5400 Tri-Band WiFi 6E Router (Archer AXE75)- Gigabit Wireless Internet Router

CORSAIR ICUE H150I ELITE CAPELLIX LIQUID CPU COOLER

CORSAIR RMx Series RM750x Fully Modular Power Supply

prepare automation framework using robot framework for Quantum Fiber product with suites like smoke, sanity, functional, and regression testing. 

include the following functionality : 
1. write few tests in python and import them as robot framework keywords similarly write few tests directly using robot keywords.
2.ability to execute test suites and also different tests using tags.
3. Able to run parallel tests.
4.ability to run cross browser testing.
5.able to run data driven testing using excel and json files.
6. Dashboard to display test results through plugins from robot framework community plugins.
7.running tests in both headless mode or non-headless mode.


Rules to follow : 

1. Follow all possible best practices.
2. Integrate the framework into Jenkins CI/CD pipeline.
3. Write & maintain interactive documentation for all the functionalities.

Note : use task master for tasks.

Automation Framework and Projects
Robot Framework Automation Setup

prepare automation framework using robot framework for Quantum Fiber product with suites like smoke, sanity, functional, and regression testing.

include the following functionality :
1. write few tests in python and import them as robot framework keywords similarly write few tests directly using robot keywords.
2.ability to execute test suites and also different tests using tags.
3. Able to run parallel tests.
4.ability to run cross browser testing.
5.able to run data driven testing using excel and json files.
6. Dashboard to display test results through plugins from robot framework community plugins.
7.running tests in both headless mode or non-headless mode.

Rules to follow :
1. Follow all possible best practices.
2. Integrate the framework into Jenkins CI/CD pipeline.
3. Write & maintain interactive documentation for all the functionalities.

Note : use task master for tasks.

Learning Goals
* 'Help me learn Python automation testing with Selenium, Robot Framework, and Playwright, providing explanations, code examples, and troubleshooting tips.'
* 'Assist me with setting up CI/CD pipelines for automation tests and using Docker for containerisation, including step-by-step guides.'
* 'Introduce me to AI/ML concepts and their applications in testing, such as test case generation or defect prediction.'
* 'Show me examples of AI productivity tools and recommend testing tools that incorporate AI or machine learning.'
* 'provide me examples, use cases, step by step instructions, anagrams to remember and code snippets (wherever possible).'

HOMELAB SETUP
CORSAIR Vengeance RGB DDR5 RAM 32GB (2x16GB) 6000MHz CL36 AMD Expo iCUE Compatible Computer Memory - Gray

AMD 7000 Series Ryzen 9 7900X Desktop Processor

GIGABYTE NVIDIA GeForce RTX 3060 WINDFORCE OC 12GB

Samsung 990 EVO SSD 2 TB

MSI X670E Gaming Plus WiFi Motherboard, ATX - Supports AMD Ryzen 7000 Series Processors, AM5, DDR5 Memory Boost 7800+MHz/OC, 3 x PCIe 5.0 x16, 1 x M.2 Gen5

Corsair iCUE 5000X RGB Tempered Glass Mid-Tower ATX PC Smart Case - Black

LG 27 (68.4 cm) UltraGear™ QHD IPS Gaming Monitor with 180Hz (O/C 200Hz), 1ms (GtG), HDR10

TP-Link AXE5400 Tri-Band WiFi 6E Router (Archer AXE75)- Gigabit Wireless Internet Router

CORSAIR ICUE H150I ELITE CAPELLIX LIQUID CPU COOLER

CORSAIR RMx Series RM750x Fully Modular Power Supply

Backend API Task
# Task ID: 2
# Title: Implement Backend API
# Status: pending
# Dependencies: None
# Priority: high
# Description: Implement the core architecture for the backend API server using Rust and the Axum framework, including setting up the database connection to PostgreSQL and Redis for caching.
# Details:
# Test Strategy:

AI Assistant Project
Project Overview
* Objective: Develop an AI assistant similar to Jarvis from the Ironman movie.

Platforms :
Web, mobile & command line

* Approach :
    * Gather and consolidate multiple AI projects from GitHub.
    * Define features and functionalities before coding.
    * Design a scalable architecture for future enhancements.

GitHub Projects :
* [Jarvis AI by Dipeshpal](https://github.com/Dipeshpal/Jarvis AI.git)
* [JARVIS by Gladiator07](https://github.com/Gladiator07/JARVIS.git)
* [JARVIS by Likhithsai2580](https://github.com/Likhithsai2580/JARVIS.git)
* [jarvis-ai by aftabrehan](https://github.com/aftabrehan/jarvis-ai.git)
* [JARVIS-ChatGPT by gia-guar](https://github.com/gia-guar/JARVIS-ChatGPT.git)
* [Jarvis-AI-using-python3 by praveenkumarsrivas](https://github.com/praveenkumarsrivas/Jarvis-AI-using-python3-.git)

* Pull features / functionality from the above attached GitHub projects.

Plugin update tracker

Execute code

Readitlater

Clear unused images

Metadata


Note toolbar

Markdown formatting assistent

Convert url to preview (iframe)

Workspace

Link embed

Pdf

Task management 

Iconic

Auto card link


Second brain

Code editor

Khoj

Vantage

Workbench

Pieces for developers

Ollama


Card view mode

Zettelflow

Obsidian query language 

Link tree

AI Providers

Settings profiles

MCP tools

Datacards

Game search

Meeting notes

Contacts

At people


Zettelkasten LLM Tools

Brain frame

Gamified Tasks

Gamification

Dataview auto complete

Geulo


d3xEPduN&%XxvC

d3xEPduN&%XxvC

Mention things





PROMPTS

[media pointer="file-service://file-BVKk5VCLPW5oa1ZWZactaD"]
studio background.A highly stylised portrait of same image with sharp features, flawless fair skin well fitted all black suites whit a black shirts.and black pants .small Gold chain at neck ,and black sunglasses and small black watches slightly unbuttoned at top , Against a bold confidently . high detail editorial photography style 4k resolution symmetrical. Composition minimal background elements 9:16 ratio

studio background.A highly stylised portrait of same image with flawless fair skin well fitted all black suites whit a black shirts.and black pants .small Gold chain at neck ,and black sunglasses and small black watches slightly unbuttoned at top , Against a bold confidently . high detail editorial photography style 4k resolution symmetrical. Composition minimal background elements 9:16 ratio

Face & Hair (Use from Selfie): Replace the original subject’s face with the face from the uploaded selfie, keeping your facial features, expression, and proportions exactly the same. Do not stylise or morph the face. However : Make the skin smooth, and flawless while keeping all natural facial details intact. 

Convert this image into Kerala bride and groom outfit where her wearing traditional Kerala saree with golden earrings, necklace and bangles with beautiful smile and her long hair and he wearing koala traditional outfit dhoti and white shirt or match with her her saree colour, are standing in a room and his hand on her shoulder and both with a cute smile in a 9:16 ratio both are same persons.





Face & Hair (Use from Selfie): Replace the original subject’s face with the face from the uploaded selfie, keeping your facial features, expression, and proportions exactly the same. Do not stylize or morph the face. However : Make the skin fair, smooth, and flawless while keeping all natural facial details intact. Style the hair to be medium-length, dark, and slightly wavy, styled naturally to fall gently over the forehead and sides.




andriod central, cnet, consumer reports, dxomark, gadgets360, gsm arena, mouth shut, nyt times, nextpit, notebookcheck, pcmag, phone arena, quora, reddit, rtings, stuff.tv, techradar, tech advisor, toms guide, trusted reviews



Camera Quality, Battery Life and Capacity, Chipset Performance, Software and AI Features, Price and Value, Design and Build Quality, Display Quality, Durability and Water Resistance, Storage Capacity and Expandability, Operating System and Software Updates, Brand Loyalty and Ecosystem Integration, Portability and Size, Additional Features and Innovations.

Robot Framework Execution Commands - Complete Reference
🤖 Robot Framework Execution Commands - Complete Reference

📋 Basic Execution
Basic command syntax:
robot [options] data_sources
python -m robot [options] data_sources

🎯 Test Selection Options
--test (-t) <name> - Selects test cases by name
--task <name> - Selects tasks by name (for RPA)
--suite (-s) <name> - Selects test suites by name
--include (-i) <tag> - Selects test cases by tag
--exclude (-e) <tag> - Excludes test cases by tag
--skip <tag> - Tests having given tag will be skipped
--skiponfailure <tag> - Tests having given tag will be skipped if they fail

📁 File and Directory Options
--extension (-F) <value> - Parse only these files when executing a directory
--parseinclude <pattern> - Parse only matching files when executing a directory
--name (-N) <name> - Sets the name of the top-level test suite
--doc (-D) <document> - Sets the documentation of the top-level test suite
--metadata (-M) <name:value> - Sets free metadata for the top level test suite
--settag (-G) <tag> - Sets the tag(s) to all executed test cases

🔄 Execution Control
--variable (-v) <name:value> - Sets individual variables
--variablefile (-V) <path:args> - Sets variables using variable files
--randomize <all|suites|tests|none> - Randomizes test execution order
--prerunmodifier <name:args> - Activate programmatic modification of test data
--prerebotmodifier <name:args> - Activate programmatic modification of results
--runemptysuite - Executes tests also if the selected test suites are empty
--dryrun - In the dry-run mode tests are run without executing keywords originating from test libraries
--exitonfailure (-X) - Stops test execution if any test fails
--exitonerror - Stops test execution if any error occurs when parsing test data, importing libraries, and so on
--skipteardownonexit - Skips teardowns if test execution is prematurely stopped

📊 Output and Reporting Options
--outputdir (-d) <dir> - Defines where to create output files
--output (-o) <file> - Sets the path to the generated output file
--legacyoutput - Creates output file in Robot Framework 6.x compatible format
--log (-l) <file> - Sets the path to the generated log file
--report (-r) <file> - Sets the path to the generated report file
--xunit (-x) <file> - Sets the path to the generated xUnit compatible result file
--debugfile (-b) <file> - A debug file that is written during execution
--timestampoutputs (-T) - Adds a timestamp to output files listed above
--splitlog - Split log file into smaller pieces that open in browser transparently
--logtitle <title> - Sets a title for the generated test log
--reporttitle <title> - Sets a title for the generated test report
--reportbackground <colors> - Sets background colors of the generated report

📈 Statistics and Logging Options
--loglevel (-L) <level> - Sets the threshold level for logging
--suitestatlevel <level> - Defines how many levels to show in the Statistics by Suite table
--tagstatinclude <tag> - Includes only these tags in the Statistics by Tag table
--tagstatexclude <tag> - Excludes these tags from the Statistics by Tag table
--tagstatcombine <tags:title> - Creates combined statistics based on tags
--tagdoc <pattern:doc> - Adds documentation to the specified tags
--tagstatlink <pattern:link:title> - Adds external links to the Statistics by Tag table
--expandkeywords <name:pattern> - Automatically expand keywords in the generated log file
--removekeywords <all|passed|name:pattern|tag:pattern|for|while|wuks> - Removes keyword data from the generated log file
--flattenkeywords <for|while|iteration|name:pattern|tag:pattern> - Flattens keywords in the generated log file
--listener <name:args> - Sets a listener for monitoring test execution

🎛️ Console Output Options
--nostatus - Sets the return code to zero regardless of failures in test cases
--console <verbose|dotted|quiet|none> - Console output type
--dotted - Shortcut for --console dotted
--quiet - Shortcut for --console quiet
--consolewidth (-W) <width> - Sets the width of the console output
--consolecolors (-C) <auto|on|ansi|off> - Specifies are colors used on the console
--consolelinks <auto|off> - Controls making paths to results files hyperlinks
--consolemarkers (-K) <auto|on|off> - Show markers on the console when top level keywords in a test case end

🔧 Advanced Options
--pythonpath (-P) <path> - Additional locations to add to the module search path
--argumentfile (-A) <path> - A text file to read more arguments from
--help (-h) - Prints usage instructions
--version - Prints the version information
--rpa - Turn on generic automation mode
--language <lang> - Activate localization
--maxerrorlines <lines> - Sets the number of error lines shown in report when tests fail
--maxassignlength <characters> - Sets the number of characters shown in log when variables are assigned

🔄 Post-Processing Commands (Rebot)
Basic rebot syntax:
rebot [options] robot_outputs
python -m robot.rebot [options] robot_outputs

Rebot-specific options:
--merge (-R) - Changes result combining behavior to merging
All other options from test execution are also available for rebot

🌍 Environment Variables
ROBOT_OPTIONS - Default options for test execution
REBOT_OPTIONS - Default options for result post-processing

💡 Common Usage Examples
Basic execution:
robot tests.robot
robot test_directory/

With options:
robot --include smoke --outputdir results tests/
robot --variable BROWSER:Chrome --loglevel DEBUG tests.robot
robot --test 'My Test' --report NONE --log NONE tests.robot

Multiple test files:
robot tests1.robot tests2.robot
robot --name 'My Suite' tests/

Post-processing:
rebot --name 'Combined Results' output1.xml output2.xml
rebot --include passed --outputdir final_results output.xml

📝 Notes
• Options can use both short (-t) and long (--test) forms
• Long options are case-insensitive and hyphen-insensitive
• Options must be given between the runner script and data sources
• Pattern matching supports wildcards (* and ?) and is case-insensitive
• Multiple values can be given by using the same option multiple times
• Environment variables can set default values for options

Generated on: August 13, 2025
Source: Robot Framework User Guide - Official Documentation

https://firefly.sunilkumarvalmiki.xyz:8080

CHATGPT TECH STACK


  Programming Languages :

-  Python : Primary language due to its simplicity and extensive ML ecosystem

-  C++ : Used for performance-critical components and system optimization

  Machine Learning Frameworks :

-  PyTorch : Primary deep learning framework for flexibility and dynamic computation graphs

-  TensorFlow : Also used in certain scenarios for scalability and production deployment

  Core Architecture :

-  Transformer Architecture : Foundation of GPT models using self-attention mechanisms

-  Generative Pre-trained Transformers (GPT) : The core language model architecture

-  Reinforcement Learning from Human Feedback (RLHF) : Used to fine-tune models like ChatGPT to align with human values

  Cloud Infrastructure :

-  Microsoft Azure : Primary cloud platform providing scalable infrastructure

-  Azure OpenAI Service : Enables cloud-based access to OpenAI models

  Hardware Accelerators :

-  GPUs (Graphics Processing Units) : For parallel computations required by neural networks

-  TPUs (Tensor Processing Units) : Google's specialized hardware for machine learning workloads

  Data Processing & Analysis :

-  NumPy : For numerical computations

-  Pandas : For data manipulation and handling large datasets

-  Matplotlib : For data visualization and performance analysis

  Deployment & API Management :

-  OpenAI API : RESTful API for accessing ChatGPT and other models

-  Docker & Kubernetes : For containerization and orchestration of services

-  Load balancing systems : To handle millions of concurrent users

  Development Tools :

-  Jupyter Notebooks : For interactive experimentation and research

-  GitHub : For version control and collaboration

  Security & Compliance :

-  Advanced encryption protocols : For data protection

-  GDPR compliance measures : For privacy and regulatory compliance

  Key Architectural Concept :

The entire system is built on  "Cloud Native Artificial Intelligence"  principles, which enables

- Rapid scaling to handle millions of users simultaneously

- Distributed computing across multiple data centers

- Real-time response generation

- High availability and fault tolerance

Telugu

CLEANUP PROMPT :
 
Do one round of complete cleanup for following scenarios : 
* Close stale PRs/issues past SLA.
 
* Remove unused deps; run security audit.
 
* Prune artifacts > 90d; delete old release assets.
 
* Rebuild docs; fix broken links.
 
* Prune untagged container images and unused volumes.
 
* Remove orphan cloud resources (IPs, disks, snapshots).
 
* Rotate secrets; delete unused service accounts/keys.
 
* Compact/retention on logs, traces, metrics.
 
* Drop temp/test tables; archive cold rows.
 
* Purge logs > policy; rotate + compress.
 
* Clear app/HTTP caches; invalidate stale CDN paths.
 
Few KPI's to measure the cleanup process :
 
* Storage reclaimed: GB/TB freed per system.
 
* Build/pipeline speed: % improvement in CI duration.
 
* Vuln & debt: fewer outdated packages, fewer critical.
 
* Costs: monthly infra/egress reduction.
 
* Reliability: fewer flaky tests, lower incident rate from config drift.
 

PROBLEM STATEMENT

Assume the role of each stakeholder involved in the comprehensive product development lifecycle, spanning from ideation to production. Engage in a thorough process of acting, discussing, debating, analyzing, optimizing, and making informed decisions regarding the proposed idea. Your objective is to produce a high-quality Product Requirements Document (PRD) that meets industry standards and is suitable for integration into any AI development tool. Ensure the document is detailed, well-structured, and includes all necessary information to guide the development process effectively.

Don’t try to ingest everything at once, instead breakdown things into multiple - small, micro and macro parts and process one after the other so we won’t go out of context length or don’t consume more tokens use advanced techniques TOON, prompt chaining, XML prompting or what-ever is feasible to get best output from the tool.I don’t like unclear, uncertainty in topics, subject or discussion or anything. I want to things from scratch to complete to understand things. Like when start explaining me something a topic, a concept or a system, if you start from g or f, I don’t get to understand it. Instead I need to get it from a to z. I’m facing so many problems on this. Help me with this issue by building a system for this.

A system which takes it can be an image/video/text/pdf/doc/xlsx/csv and other file formats. Ingest it into your memory, file size limit is 10 gb do a well-grounded/advanced research on that uploaded item from multiple sources. Write a detailed, elaborated & complete notes on that topic/concept.i can download this notes onto my local system or upload it to cloud drives like google drive.  Visualize the data inside of the notes beautifully using different format and understanding levels. Notes should get converted to different learnings formats like 5 years old kid understanding level, phd level, student level and other levels. We should be able to establish relationships between these data inside of notes. Create knowledge bases using ai models, tags, organize, optimize and etc using ai. Create images/documents/videos/pdfs and etc from the notes.import notes from one note, obsidian, Evernote, and other platforms. There is no size or limit for notes (unlimited). the system should be so fast like a cheetah and shouldn’t lag. I should be able to use It on Mac, windows, android, iOS and other platforms like docker, podman and etc. fetch data from YouTube videos, YouTube reels, instagram reels, articles, posts and articles form medium or blogs, websites and other platforms to make notes either using ai or user can write notes. Can rewrite ot review and rate the responses of ai. Mcp support, llm models support, plugins support and other recent advancements in ai like google a2a and claude’s mcp, connectors and self-learning and self-improving or correcting agents. We will keep improving this features and functionality. It should work on web, windows, android, iOS, linux, Mac and other platforms like docker, podman or other platforms. System should be too flexible, it should be scalable, flexible, fast and preferment and etc. the frontend ui should also be sofas like cheetah(no lag/no hang) data should be permanent and no limits for it. We should be able to integrate any open source models, or paid models or custom models from hugging face or some other platforms using api key or some other. I should be able to use this on my work laptop, which has restrictions like batch, cmd and other scripts on windows 11 laptop. browse internet and find if there are any implemented products, then do an well-grounded/complete/advanced research on those products by grabbing docs, source-code and other data forms or formats. And we will implement those features and functionalities into our product (notebooklm, got teacher, udemy, coursera) the system should also search and scrape research papers on the given topic/concept. Threads, instagram, YouTube, twitter, medium, tech blogs or other popular platforms like forums, blogs, communities like meetup. 

I should be able to self-host it or run in my local machines or put it in cloud, system should support all modes. System should be always ready to adapt to new architecture or new integration of other system. System should self-learn from mistakes and patterns and other sources.each feature or functionality should be modular and scalable so putting down one component won’t affect other components. 

1. Task

You will receive a problem description:
Problem Description:{{problem_description}}
Your job is to:
1. Understand the problem and its constraints.
2. Evaluate multiple suitable programming languages.
3. Compare and rank them for this specific use case.
4. Choose the most appropriate language(s) and justify the choice.
5. Only then, produce code and detailed guidance in the chosen language(s).

2. Hard Rules (Non-Negotiable)

1. Do not default to Python.
    * You must explicitly consider multiple languages before picking any one language.
    * You must treat Python as one candidate among many, not the default.
2. Use Python only when truly justified.
    * Use Python only if your comparison and ranking clearly shows Python is the best choice for this exact problem and constraints.
    * If Python is not ranked #1, you must not use Python for the main solution.
3. Check for alternative languages.
    * Assume by default that the solution can be implemented in multiple languages (C, C++, Rust, Go, Java, Kotlin, TypeScript/Node.js, C#, etc.).
    * If you have internet access / browsing:
        * Search the web to confirm which languages are commonly used for this kind of problem.
        * Use that information to update your ranking and mention the sources at a high level (no links needed, just names and quick reference).
    * If you do not have internet access:
        * Explicitly state that you are relying on your internal knowledge without live web verification.
4. Explain your reasoning clearly.
    * You must show your reasoning step-by-step for:
        * How you understood the problem.
        * How you selected candidate languages.
        * How you ranked them.
        * Why you chose the final language(s).
    * Do not skip directly to code.
5. If multiple components exist, you may choose multiple languages.
    * Example: backend API in Go, data pipeline in Rust, frontend in TypeScript/React.
    * Clearly explain which language is used for which component and why.

3. Language Selection and Comparison Process

Before writing any code, follow this exact sequence:

3.1 Identify Candidate Languages

Create a list of at least 3–5 reasonable candidate languages for this problem.When relevant, consider languages from different categories, such as:
* Systems / high-performance: C, C++, Rust
* Backend / services: Go, Java, Kotlin, C#, Rust
* Scripting / glue / automation: Python, JavaScript/TypeScript (Node.js), Ruby
* Frontend / UI: TypeScript/JavaScript (React, Vue, Angular, Svelte), etc.
* Data / analytics: Python, R, Julia, Rust, etc.
You may add others if they are appropriate.

3.2 Define Evaluation Criteria

For this specific problem, evaluate each language using these criteria (adapt or extend if needed):
* Runtime performance: latency, throughput, memory usage.
* Developer productivity: speed of development, simplicity.
* Ecosystem & libraries: maturity and availability of libraries/frameworks for this use case.
* Maintainability & readability: long-term code health, clarity.
* Tooling & debugging: IDE support, debuggers, profilers, linters.
* Reliability & safety: type system, memory safety, error handling.
* Concurrency & scalability: if applicable for this problem.
* Interoperability: integration with other systems/languages in the stack.
* Deployment & hosting: ease of running in containers, cloud, serverless, etc.
* Team skill assumptions (if provided by user): if user mentions preferred or known languages, factor that in.

3.3 Build a Comparison Table

Produce a small table where rows = languages and columns = criteria.
Include short notes, not essays, such as:
Language	Performance	Ecosystem	Dev Speed	Safety	Concurrency	Deployment	Notes
Rust	Very high	Good	Medium	Strong	Strong	Good	Great for low-latency, safe systems.
Go	High	Very good	High	Good	Strong	Excellent	Simple, great for web services.
Python	Medium/low	Excellent	Very high	Medium	Limited	Good	Fast to prototype, slower runtime.
Adjust based on the problem.

3.4 Rank the Languages

For this specific use case, provide a ranked list:

Language Ranking for This Problem
1. Language A – with justification
2. Language B – with justification
3. Language C – with justification

Make sure the ranking is based on the actual problem, not on general popularity.

3.5 Choose the Final Language(s)

From the ranking:
* Pick the top 1–2 languages and explicitly justify:
    * Why they are best for this exact problem.
    * Why you are not choosing the others.
* After choosing:
    * Lock in the language(s) and use them consistently in the rest of the answer.
Python-specific rule:If Python is not ranked #1, you must not pick Python as the primary implementation language.If Python is ranked #1, explicitly state why (e.g., heavy ML usage, fastest iteration, existing Python ecosystem, etc.).

4. Implementation Guidelines
Once the language(s) are chosen, then and only then:
1. High-level design first.
    * Show the architecture.
    * Show modules/components.
    * Explain data flow and major responsibilities.
2. Then code.
    * Provide well-structured, production-oriented examples, not toy snippets.
    * Include:
        * Project structure (folders, files).
        * Core code examples.
        * Any important config (build tools, package managers, Dockerfile outline, etc.).
    * Write idiomatic code following best practices for that language.
3. Performance & scalability notes.
    * Explain how the chosen language and design will handle:
        * Expected load.
        * Scaling (horizontal/vertical).
        * Performance optimizations were relevant.
4. Testing & CI/CD.
    * Recommend testing strategies and libraries for this language.
    * Outline how this code can be integrated into CI/CD pipelines.
    * Mention static analysis / linters / formatters for that language.

5. Web / Research Requirement (If Available)

If the AI system has web access:
1. Search for real-world usage of this problem type in different languages:
    * Example: “high performance REST API in Rust vs Go”, “ML serving in Python vs Java”, etc.
2. Use findings to:
    * Validate your language choices.
    * Reference common patterns, frameworks, or well-known tools.
3. If research contradicts your initial ranking, update your ranking and explain the change.
If web access is not available, explicitly state:
“Web access is not available. I am using my internal knowledge without live verification.”

6. Output Format

Always structure your response in this order:
1. Problem Understanding
    * Short summary of what needs to be built.
2. Candidate Languages & Criteria
    * List of languages considered.
    * The evaluation criteria used.
3. Comparison Table
    * A compact table comparing languages.
4. Ranking & Final Choice
    * Ranked list.
    * Explanation of the final chosen language(s).
    * Explicit mention of why Python is or is not chosen.
5. High-Level Design
    * Architecture.
    * Components/modules.
6. Implementation in Chosen Language(s)
    * Project structure.
    * Code examples.
    * Important configs.
7. Performance, Testing, and Deployment Notes
    * Optimization ideas.
    * Testing strategies.
    * CI/CD and deployment guidance.

If the user later asks specifically for code in another language (e.g., “now show this in Rust instead of Go”), you may provide an additional implementation in that requested language, and you should say how the trade-offs change.


Iteratively execute the loop until the desired output is consistently achieved, ensuring that each iteration brings measurable improvements or meets the predefined success criteria.

1. Validation of Criteria:

    1. Thoroughly verify that all the previously outlined criteria are fully met and valid.

    2. Implement checkpoints to regularly assess adherence to these criteria throughout the process.

2. Grammatical and Spelling Review:

    1. Conduct a meticulous review for any grammatical or spelling errors.

    2. If errors are identified, promptly rewrite the affected sections to ensure grammatical correctness and clarity.

3. Optimization Without Compromising Goals:

    1. Evaluate the current output to identify potential areas for optimization.

    2. Apply optimization techniques cautiously to enhance performance or clarity without disturbing the core objectives or altering the intended outcome.

4. Adherence to Best Practices:

    1. Consistently follow industry-standard best practices relevant to the task.

    2. Stay updated with the latest methodologies and incorporate them where applicable to improve overall efficiency and effectiveness.

If python is required, create separate virtual environment so I went conflict with other packages of system. Use some popular package manager like uv instead of default pip.
Do a well-grounded/advanced research on each and every piece of this problem statement from multiple source before preparing the result.

PROBLEM STATEMENT

Background and Context:

The increasing integration of AI tools into software development workflows has transformed how rules and workflows are created, managed, and executed. Understanding the lifecycle of these elements—including creation, maintenance, and deletion—is critical to maximizing productivity, ensuring code quality, and enhancing automation capabilities.

Objective:

Conduct comprehensive, in-depth research on how AI tools manage the complete lifecycle of rules and workflows. The study should cover best practices, technical feasibility, current tools (both free and paid), and identify potential issues and solutions related to the automation and execution of these rules and workflows.

Key Research Areas:

1. Rule and Workflow Creation:
    * Can AI tools autonomously create rules and workflows based on contextual data or codebases?
    * Evaluate AI’s capability to adapt to different environments and generate context-specific rules.
2. Application of Rules and Workflows:
    * Determine if AI tools can directly integrate rules/workflows into codebases without manual intervention.
    * Assess automation levels and required user inputs.
3. Optimization and Organization:
    * Investigate AI’s ability to break down complex workflows, optimize, rewrite, and reorganize them independently.
4. Placement of Rules and Workflows:
    * Best practices for the placement of global vs. workspace/user-specific rules.
    * Optimal storage and structuring of global and user workflows.
5. Execution Mechanisms:
    * How AI tools execute rules and workflows across different platforms.
    * Feasibility of automatic execution on every code save.
6. Best Practices:
    * Establish standards for rule/workflow management to ensure efficiency, scalability, and maintainability.
7. Error Handling and Issue Identification:
    * Common problems, errors, and inefficiencies encountered in rule/workflow management.
    * Strategies for debugging and resolving such issues effectively.
8. Tool Landscape:
    * Survey of free, paid, and open-source tools relevant to this domain.
    * Comparative analysis of their features, strengths, and limitations.
9. Latest Advancements:
    * Exploration of cutting-edge developments and innovations related to AI-driven rule and workflow management.

Deliverable:

All findings should be compiled into a comprehensive document titled “RESEARCH_ON_RULES_and_WORKFLOWS.md.” This document should:
* Provide clear, well-structured insights.
* Include evidence-backed recommendations.
* Highlight gaps in current technologies and propose potential solutions.

Success Criteria:

* Depth and breadth of research covering all specified areas.
* Identification of actionable best practices.
* Clear differentiation between capabilities of current tools.
* Practical recommendations for improving productivity through AI-driven workflows.


ROUGH

Assume the role of a highly experienced Product Manager with over 20 years of expertise in developing diverse software products across various domains. Your primary responsibility is to meticulously analyze and interpret provided statements, preliminary concepts, or research themes. Transform these initial, often unstructured ideas into well-crafted, professional problem statements.

Your output should be optimized for seamless integration into AI development tools, ensuring clarity, precision, and actionable insights. Apply industry-leading best practices, including:
1. Deep Analysis: Break down the core components of the given idea to identify underlying challenges and objectives.
2. Structured Formatting: Present the problem statement in a clear, concise manner with defined goals, constraints, and success criteria.
3. Contextual Understanding: Incorporate relevant background information to provide comprehensive context for AI tools.
4. Objective Clarity: Ensure the problem statement highlights the key outcomes expected from the AI development process.
5. Iterative Refinement: Reassess and refine the statement to enhance its effectiveness and alignment with AI capabilities.

Leverage your extensive industry knowledge and current best practices to deliver high-quality, detailed problem statements that drive effective AI development.

LEARNING PROMPT

"I am looking to build a comprehensive understanding of Python automation testing using Selenium, Robot Framework, and Playwright. Please provide detailed explanations of each tool, including their core features, architecture, and practical use cases. I would appreciate code examples that illustrate best practices, common patterns, and troubleshooting tips that address frequent issues encountered during automation testing.

Additionally, assist me in setting up CI/CD pipelines specifically geared towards automation tests. This should include step-by-step guides covering the integration of automation frameworks into CI/CD pipelines, configuration of build tools, and deployment strategies. Furthermore, provide insights on utilizing Docker for containerization, detailing the process of creating Docker images, managing containers, and integrating them within CI/CD workflows.

Introduce me to AI/ML concepts with a focus on their applications in software testing. Examples should include test case generation, defect prediction, and performance optimization. Explain how these technologies can enhance testing efficiency and reliability. Wherever possible, supplement explanations with real-world use cases, illustrative examples, and code snippets.

Showcase examples of AI productivity tools relevant to the testing domain. Recommend automation testing tools that incorporate AI or machine learning, describing their functionalities, advantages, and practical applications in various testing scenarios.

For each topic, please include:
* Detailed use cases and examples
* Step-by-step instructions
* Mnemonics or anagrams to aid memory retention
* Relevant code snippets to reinforce learning
* Troubleshooting tips to address common challenges

Ensure the information is structured logically, facilitating a gradual and thorough understanding of each concept."

Refinements:
1. "Simplify the language and structure to cater to beginners in automation testing, focusing on clear, concise explanations."
2. "Add a section comparing the pros and cons of each tool and technology mentioned to aid decision-making."
3. "Format the content as a structured learning path with modules, objectives, and checkpoints for better learning progression."

ATTENDANCE AUTOMATION

I have this website, called BEEHIVE (https://satech.beehivehcm.com/) where I need to submit my punch-in at 9:30 AM in the morning and punch-out at 6:30 PM in the evening everyday and also I need submit attendance for previous day before punching-in for today because we can’t submit for particular day on the same day .I we have top auth for logging-in into this website.first we login with username and password and then it asks for otp and then submit attendance for previous day and then push-in for today.


Process :

1. Every day at 9:30 AM in the morning, open the SA tech beehive portal ( https://satech.beehivehcm.com/ ).
2. On the beehive_login.png page login using the given credentials.
3. It will trigger an otp to the mobile number & email.
4. Once correct OTP is entered, then it login into the portal.
5. After we will be on satech_beehive_homepage.png page.
6. On the homepage select/click dotted menu icon (menu_icon.png)
7. Then menu popup is displayed (menu_selected.png)
8. Click on attendance icon (attendance.png).
9. Then will navigated to attendance_page.png page.
10. Click on daily attendance button on the sidebar (daily_attendance_selected.png)
11. Then we will be navigated to calendar.png page where we should and find today tile (calendar.png)
12. On calendar.png page we should not see absent(absent.png), holiday(holiday.png), leave(leave.png).
13. Then, click on sa-tech_logo.png icon the page.
14. Then, will navigate to main home page, then click on regularize attendance button (regularise_attendance.png)
15. Then, on attendance_regularization.png page, click on slect_regu_date.png input field.
16. Then calendar shows up on the image (reg_calender.png) popup.
17. Select previous day’s date, once date popedup.
18. Then click on eg_reason.png input box. Enter work from home on the input box. 
19. Then clikck on reg_submit.png button.
20. Then, reg_popup.png popup is displayed.
21. Then click on reg_ok.png ok button.
22. Then, we will navigated to attendance_applied.png page, where we can check that attendance is applied.

Look out for all automation possibilities for this automation either in web or in mobile app, we have a mobile app for this swell ( beehive : https://play.google.com/store/apps/details?id=com.app.beehivehrms) using automate or taster for android.

What is the feassibility of this automation, since its involves OTP triggering and submission. research & Validate different automation possibilities  and pick the best one from it.

Before starting to write PRD for this, do a well-grounded research on this and then proceed with pre generation.

This should work on work laptop where we have restrictions on bath, cmd and other script execution is blocked due to it policy.

May be in docker, or some other way or research on all possible automation for this scenario.


 
CHATGPT PROJECTS SETUP


Variables:

* {{project_goal}}: Provide a clear, concise description of the primary objective of the ChatGPT project. This should outline the purpose and intended impact of the project.
* {{expected_output}}: Define the desired outcome or tangible result. Specify how success will be measured and what form the output should take.
* {{requirements}}: List all specific needs, prerequisites, resources, tools, data sets, or technologies essential for the project’s execution.
* {{constraints}}: Identify limitations, restrictions, or boundaries such as timeframes, resource availability, technical limitations, compliance issues, or other critical parameters.
* {{steps}}: Present a detailed, sequential list of actions required to complete the project, including dependencies and milestones where applicable.

Best Practices for Writing Project Instructions:

1. Clarify Objectives and Outcomes:
    * Explicitly state the {{project_goal}} and {{expected_output}} at the beginning to establish clear expectations and purpose.
2. Detail Requirements and Constraints:
    * Clearly enumerate {{requirements}} and {{constraints}} to ensure all team members understand the project’s scope and limitations.
3. Use Clear, Concise Language:
    * Avoid ambiguous terminology.
    * Eliminate unnecessary jargon unless it serves a specific, understood purpose.
    * Maintain consistency in terminology throughout the document.
4. Break Down Complex Instructions:
    * Divide intricate tasks into manageable, logical steps under the {{steps}} section.
    * Use bullet points or numbered lists for clarity.
5. Optimize for ChatGPT’s Input Capabilities:
    * Ensure instructions are thorough yet succinct to fit within ChatGPT’s input length constraints.
    * Focus on relevance and prioritize vital details.
6. Iterative Review and Refinement:
    * Reassess instructions periodically for clarity, completeness, and conciseness.
    * Test the instructions to confirm they generate the expected results with ChatGPT.

Automatic Population of Variables:

* Upon receiving a project title, utilize trusted internet resources to gather data and auto-populate the variables ({{project_goal}}, {{expected_output}}, {{requirements}}, {{constraints}}, {{steps}}).
* Present the auto-generated data to the user for review, validation, and necessary adjustments to ensure accuracy.

Advanced Validation and Optimization:

1. Validation of Criteria:
    * Implement checkpoints to regularly verify that all outlined criteria are met throughout the project lifecycle.
    * Use feedback loops to ensure continuous alignment with project goals.
2. Grammatical and Spelling Review:
    * Conduct meticulous reviews to identify and correct all grammatical and spelling errors.
    * Employ advanced grammar checking tools for thorough validation.
3. Optimization Without Compromising Goals:
    * Identify areas for enhancement in clarity, performance, or efficiency without deviating from the core objectives.
    * Apply optimization techniques carefully to maintain the intended outcome.
4. Adherence to Industry Best Practices:
    * Consistently integrate the latest methodologies and best practices to enhance project effectiveness.
    * Stay informed about updates to ChatGPT’s functionalities to leverage new capabilities efficiently.

INSTRUCTIONS FOR AI TOOL TO NOT TO DEFAULT PYTHON


1. Task

You will receive a problem description:
Problem Description:{{problem_description}}
Your job is to:
1. Understand the problem and its constraints.
2. Evaluate multiple suitable programming languages.
3. Compare and rank them for this specific use case.
4. Choose the most appropriate language(s) and justify the choice.
5. Only then, produce code and detailed guidance in the chosen language(s).

2. Hard Rules (Non-Negotiable)

1. Do not default to Python.
    * You must explicitly consider multiple languages before picking any one language.
    * You must treat Python as one candidate among many, not the default.
2. Use Python only when truly justified.
    * Use Python only if your comparison and ranking clearly shows Python is the best choice for this exact problem and constraints.
    * If Python is not ranked #1, you must not use Python for the main solution.
3. Check for alternative languages.
    * Assume by default that the solution can be implemented in multiple languages (C, C++, Rust, Go, Java, Kotlin, TypeScript/Node.js, C#, etc.).
    * If you have internet access / browsing:
        * Search the web to confirm which languages are commonly used for this kind of problem.
        * Use that information to update your ranking and mention the sources at a high level (no links needed, just names and quick reference).
    * If you do not have internet access:
        * Explicitly state that you are relying on your internal knowledge without live web verification.
4. Explain your reasoning clearly.
    * You must show your reasoning step-by-step for:
        * How you understood the problem.
        * How you selected candidate languages.
        * How you ranked them.
        * Why you chose the final language(s).
    * Do not skip directly to code.
5. If multiple components exist, you may choose multiple languages.
    * Example: backend API in Go, data pipeline in Rust, frontend in TypeScript/React.
    * Clearly explain which language is used for which component and why.

3. Language Selection and Comparison Process

Before writing any code, follow this exact sequence:

3.1 Identify Candidate Languages

Create a list of at least 3–5 reasonable candidate languages for this problem.When relevant, consider languages from different categories, such as:
* Systems / high-performance: C, C++, Rust
* Backend / services: Go, Java, Kotlin, C#, Rust
* Scripting / glue / automation: Python, JavaScript/TypeScript (Node.js), Ruby
* Frontend / UI: TypeScript/JavaScript (React, Vue, Angular, Svelte), etc.
* Data / analytics: Python, R, Julia, Rust, etc.
You may add others if they are appropriate.

3.2 Define Evaluation Criteria

For this specific problem, evaluate each language using these criteria (adapt or extend if needed):
* Runtime performance: latency, throughput, memory usage.
* Developer productivity: speed of development, simplicity.
* Ecosystem & libraries: maturity and availability of libraries/frameworks for this use case.
* Maintainability & readability: long-term code health, clarity.
* Tooling & debugging: IDE support, debuggers, profilers, linters.
* Reliability & safety: type system, memory safety, error handling.
* Concurrency & scalability: if applicable for this problem.
* Interoperability: integration with other systems/languages in the stack.
* Deployment & hosting: ease of running in containers, cloud, serverless, etc.
* Team skill assumptions (if provided by user): if user mentions preferred or known languages, factor that in.

3.3 Build a Comparison Table

Produce a small table where rows = languages and columns = criteria.
Include short notes, not essays, such as:
Language	Performance	Ecosystem	Dev Speed	Safety	Concurrency	Deployment	Notes
Rust	Very high	Good	Medium	Strong	Strong	Good	Great for low-latency, safe systems.
Go	High	Very good	High	Good	Strong	Excellent	Simple, great for web services.
Python	Medium/low	Excellent	Very high	Medium	Limited	Good	Fast to prototype, slower runtime.
Adjust based on the problem.

3.4 Rank the Languages

For this specific use case, provide a ranked list:

Language Ranking for This Problem
1. Language A – with justification
2. Language B – with justification
3. Language C – with justification

Make sure the ranking is based on the actual problem, not on general popularity.

3.5 Choose the Final Language(s)

From the ranking:
* Pick the top 1–2 languages and explicitly justify:
    * Why they are best for this exact problem.
    * Why you are not choosing the others.
* After choosing:
    * Lock in the language(s) and use them consistently in the rest of the answer.
Python-specific rule:If Python is not ranked #1, you must not pick Python as the primary implementation language.If Python is ranked #1, explicitly state why (e.g., heavy ML usage, fastest iteration, existing Python ecosystem, etc.).

4. Implementation Guidelines
Once the language(s) are chosen, then and only then:
1. High-level design first.
    * Show the architecture.
    * Show modules/components.
    * Explain data flow and major responsibilities.
2. Then code.
    * Provide well-structured, production-oriented examples, not toy snippets.
    * Include:
        * Project structure (folders, files).
        * Core code examples.
        * Any important config (build tools, package managers, Dockerfile outline, etc.).
    * Write idiomatic code following best practices for that language.
3. Performance & scalability notes.
    * Explain how the chosen language and design will handle:
        * Expected load.
        * Scaling (horizontal/vertical).
        * Performance optimizations were relevant.
4. Testing & CI/CD.
    * Recommend testing strategies and libraries for this language.
    * Outline how this code can be integrated into CI/CD pipelines.
    * Mention static analysis / linters / formatters for that language.

5. Web / Research Requirement (If Available)

If the AI system has web access:
1. Search for real-world usage of this problem type in different languages:
    * Example: “high performance REST API in Rust vs Go”, “ML serving in Python vs Java”, etc.
2. Use findings to:
    * Validate your language choices.
    * Reference common patterns, frameworks, or well-known tools.
3. If research contradicts your initial ranking, update your ranking and explain the change.
If web access is not available, explicitly state:
“Web access is not available. I am using my internal knowledge without live verification.”

6. Output Format

Always structure your response in this order:
1. Problem Understanding
    * Short summary of what needs to be built.
2. Candidate Languages & Criteria
    * List of languages considered.
    * The evaluation criteria used.
3. Comparison Table
    * A compact table comparing languages.
4. Ranking & Final Choice
    * Ranked list.
    * Explanation of the final chosen language(s).
    * Explicit mention of why Python is or is not chosen.
5. High-Level Design
    * Architecture.
    * Components/modules.
6. Implementation in Chosen Language(s)
    * Project structure.
    * Code examples.
    * Important configs.
7. Performance, Testing, and Deployment Notes
    * Optimization ideas.
    * Testing strategies.
    * CI/CD and deployment guidance.

If the user later asks specifically for code in another language (e.g., “now show this in Rust instead of Go”), you may provide an additional implementation in that requested language, and you should say how the trade-offs change.

PRD TEMPLATE


1. Document Metadata

PRD_Title:
Version:
Last_Updated:
Author:
Reviewers:
Status: (Draft / Review / Approved)
Target_Release:

2. Executive Summary

A brief, high-signal explanation of what this product is and why it exists.

Product_Overview:
Problem_Statement:
Proposed_Solution:
Target_User:
Product_Scope: (In-Scope / Out-of-Scope)
Success_Metrics_Summary:

3. Product Vision & Strategy

Vision_Statement:
Mission_Alignment:
Long_Term_Goals:
Short_Term_Goals:
North_Star_Metric:
Strategic_Bets:
Risks_and_Mitigations:

4. Background & Context

Market_Research_Summary:
Competitor_Analysis:
Existing_Solutions_and_Gaps:
User_Insights_and_Research:
Business_Opportunity:
Why_Now:

5. User Personas

For AI tools: always describe users with goals, motivations, frustrations.

Persona_1:
    Name:
    Role:
    Goals:
    Pains:
    Environment:

Persona_2:

Primary_User:
Secondary_User:
Anti_User:

6. Problem Definition

Core_Problems:
User_Pain_Points_In_Detail:
Business_Pain_Points:
Root_Cause_Analysis (5 Whys or Fishbone):
Opportunity_Hypothesis:

7. Product Scope

In Scope -

Feature_List_In_Scope:
Capabilities:
Supported_Platforms:
Supported_Integrations:
User_Journeys:

Out of Scope -
Non_Goals:
Future_Considerations:

8. Objectives & Key Results (OKRs)

Objective_1:
    KR1:
    KR2:

Objective_2:
    KR1:
    KR2:

9. Feature Breakdown (Epic → Feature → User Story → Acceptance Criteria → Non-Functional Requirements)

EPIC Template

Epic_Name:
Epic_Description:
Linked_Objectives:
Dependencies:
FEATURE Template
Feature_Name:
Feature_Description:
Value_Proposition:
Priority: (P0/P1/P2)
Risks:
Assumptions:
Dependencies:
USER STORY Template (AI-Optimized)
As_a:
I_want_to:
So_that:

User_Flow_Steps:
Acceptance_Criteria: (Gherkin Format Recommended)
    Given:
    When:
    Then:

Business_Rules:
Error_States:

10. UX & UI Requirements

User_Flows:
Wireframe_Descriptions:
UI_Constraints:
Accessibility_Standards:
Localization_Requirements:
Navigation_Model:
Information_Architecture:
Design_System_Used:

11. Technical Requirements

Explicit, machine-friendly formatting works best for AI.

System_Architecture_Requirements:
Tech_Stack:
API_Requirements:
    Endpoints:
    Methods:
    Request_Formats:
    Response_Formats:
    Auth/Token_Flow:

Data_Model_Requirements:

    Entities:
    Attributes:
    Relationships:

Infrastructure_Requirements:

    Cloud:
    Containers:
    CI/CD:
    Environments: (Dev / Stage / Prod)

Performance_Requirements:
Reliability_Requirements:
Security_and_Compliance:
Scalability_Requirements:

12. AI/ML Requirements (Optional but Modern)

Is_AI_Used: (Yes/No)
AI_Model_Purpose:
Input_Data:
Output_Data:
Training_Method:
Evaluation_Metrics:
Hallucination_Prevention:
Safety_Guards:
Explainability_Requirements:
Latency_Constraints:
Integration_with_Product:

13. Data Requirements

Data_Sources:
Data_Flow:
Data_Retention:
Data_Privacy:
PII_Handling:
Encryption_Standards:
Audit_Logs:
Backup_Requirements:

14. Success Metrics

Break down into customer, business, technical.

Customer_Metrics:
Business_Metrics:
Technical_Metrics:
AI_Metrics (if applicable):

North_Star_Metric:

15. Release Plan
MVP_Definition:
MVP_Features:
Release_Phases:
Launch_Criteria:
Rollback_Plan:

16. Analytics & Telemetry

Events_to_Capture:
Funnels:
Dashboards:
Insight_Strategy:
A/B_Testing_Strategy:

17. Dependencies & Constraints

Technical_Dependencies:
Team_Dependencies:
Third_Party_Dependencies:
Operational_Constraints:
Legal/Compliance_Constraints:
Budget_Constraints:
Timeline_Constraints:

18. Risks & Mitigation Plan

Risk_1:
Severity:
Likelihood:
Mitigation:

Risk_2:

19. Open Questions
Question_1:
Question_2:
Question_3:

20. Appendix

Glossary:
Reference_Documents:
API_Specs:
Architecture_Diagrams:
Research_Documents_Links:
Benchmarks:

OPEN-JARVIS

Project Overview

* Objective: Develop an AI assistant similar to Jarvis from the Ironman movie.

Platforms :

Web, mobile & command line

* Approach : 

    * Gather and consolidate multiple AI projects from GitHub.
    * Define features and functionalities before coding.
    * Design a scalable architecture for future enhancements.

GitHub Projects :

* [JarvisAI by Dipeshpal](https://github.com/Dipeshpal/JarvisAI.git)
* [JARVIS by Gladiator07](https://github.com/Gladiator07/JARVIS.git)
* [JARVIS by Likhithsai2580](https://github.com/Likhithsai2580/JARVIS.git)
* [jarvis-ai by aftabrehan](https://github.com/aftabrehan/jarvis-ai.git)
* [JARVIS-ChatGPT by gia-guar](https://github.com/gia-guar/JARVIS-ChatGPT.git)
* [Jarvis-AI-using-python3 by praveenkumarsrivas](https://github.com/praveenkumarsrivas/Jarvis-AI-using-python3-.git)

- Pull features / functionality from the above attached GitHub projects.

* Additional Projects: Feel free to pull from GitHub if other projects are beneficial.

Project Motive

* Free Access: The project will be completely free, using ollama and other free alternatives instead of open APIs.

Branch Structure

* main: Production code resides here; direct merging is not allowed.
* test: Runs various tests (UI, functional, regression).
* dev: Development environment; code is pushed here.

Development Process

1. Code Push: 
    * Dev pushes code to the dev branch.
    * Automatic resolution and commit of merge conflicts.

1. Testing:
    * Code is pushed to the test branch.
    * All tests, dependency checks, and Dependabot alerts are executed.
    * Code is pushed to the main branch only if all tests pass.
    * Issues are created if tests fail.

Guidelines

1. Citations: Remove all citations and referral links to ensure the project is free from external references.
2. Best Practices: Adhere to CI/CD and Python best practices.
3. Scalability: Design for future feature additions and improvements.
4. Branch Limit: Stick to the main, test, and dev branches.
5. Functionality: Ensure no existing functionality is broken; test locally for every change.
6. File Management: Avoid creating duplicate files; check the entire project tree.
7. Iterative Development: Implement changes quickly to reach the market faster.
8. Scalable Configuration: Use environment or config files instead of hardcoding values.
9. Cleanup: Clean up before committing to GitHub.
10. Readme Updates: Update the README.MD with the latest changes in every iteration.

Tech Stack

* Programming Language: Use any language, prioritising quality without compromise.

PROMPTS (ORI)

PRD WRITER :

Assume the role of each stakeholder involved in the comprehensive product development lifecycle, spanning from ideation to production. Engage in a thorough process of acting, discussing, debating, analyzing, optimizing, and making informed decisions regarding the proposed idea. Your objective is to produce a high-quality Product Requirements Document (PRD) that meets industry standards and is suitable for integration into any AI development tool. Ensure the document is detailed, well-structured, and includes all necessary information to guide the development process effectively.

PROMPT WRITER :

As a seasoned prompt writer with over a decade of experience in crafting effective prompts for AI tools, I am tasked with creating an expanded and detailed version of a given prompt. This involves conducting thorough research on the internet to gather the most current and effective best practices. My goal is to ensure that the rewritten prompt is not only comprehensive but also optimized for the specific AI tool in use, maximizing its potential and accuracy. By leveraging my extensive experience and the latest insights, I aim to deliver a high-quality prompt that meets the specific requirements and objectives of the task.


Comprehensive Note-Taking System with Obsidian on Docker

Product Requirements Document (PRD)

Title: Comprehensive Note-Taking System with Obsidian on Docker

Version: 1.0

Date: [Insert Date]

Authors: [Insert Authors/Stakeholders]

⸻
1. Executive Summary
This PRD outlines a robust, scalable, cross-platform note-taking system using Obsidian deployed via Docker. The system ensures seamless synchronization, high security standards, and efficient performance across devices including Windows and macOS laptops, Android smartphones, and browser-based access. Advanced AI integrations enhance note management and productivity.

⸻
2. Stakeholders
* Product Owner: [Insert Name]
* Technical Lead: [Insert Name]
* DevOps Engineer: [Insert Name]
* Security Specialist: [Insert Name]
* QA Engineer: [Insert Name]
* End Users: [Insert Names/Profiles]

⸻
3. Goals and Objectives
* Seamless Note-Taking: Lag-free, responsive performance.
* High Scalability: Efficient handling of large note vaults.
* Reliable Syncing: Automated, conflict-free synchronization.
* Robust Security: Data integrity through secure Docker images.
* Cross-Platform Compatibility: Support for Windows, macOS, Android, and browser-based access.

⸻
4. Assumptions and Constraints
* Assumptions:
    * Users are familiar with basic Docker commands.
    * Google Drive is the preferred sync platform.
* Constraints:
    * Compatibility with enterprise proxies like Zscaler.
    * Limited resources on mobile devices.

⸻
5. Detailed Requirements
5.1 Functional Requirements
1. Deployment & Setup:
    * Dockerized Obsidian for Windows, macOS.
    * Kubernetes support for optional advanced deployment.
2. Synchronization:
    * Google Drive integration via rclone.
    * FolderSync for Android devices.
3. Security:
    * Encrypted data transmission (SSL/TLS).
    * Vulnerability scanning with Trivy.
4. AI Integrations:
    * Automated note tagging.
    * Content summarization.
    * Dynamic knowledge graphs.

5.2 Non-Functional Requirements
* High availability and minimal downtime.
* Optimized performance with minimal resource consumption.
* User-friendly setup for non-technical users.

⸻
6. Architecture Design
* Core Components: Docker, Kubernetes (optional), Google Drive, FolderSync, AI models.
* Device-Specific Configurations:
    * Windows/Mac: Docker Compose, robust sync with Google Drive.
    * Android: Obsidian Mobile + FolderSync.
* Security Layers: SSL/TLS, vulnerability scans.

[Insert Architecture Diagram Here]

⸻
7. Implementation Guide
1. Windows Setup: Install Docker Desktop, deploy Obsidian images.
2. macOS Setup: Optimized Docker Compose configuration.
3. Android Setup: Obsidian Mobile app + FolderSync configuration.

[Insert Step-by-Step Guides with Screenshots]

⸻
8. Troubleshooting Guide
* Common Issues: Sync conflicts, Docker container failures.
* Resolutions: Clear error logs, script-based conflict detection.

⸻
9. Testing and Validation
* Unit Tests: For deployment scripts.
* Integration Tests: For synchronization flows.
* Security Audits: Regular vulnerability assessments.

⸻
10. Maintenance Plan
* Automation Scripts: For updates and backups.
* Monitoring: Prometheus and Grafana dashboards.
* Regular Audits: Performance and security checks.

⸻
11. Future Enhancements
* Advanced AI capabilities with GPT models.
* Dynamic resource management using Kubernetes.

⸻
12. Appendices
* User Manuals: Installation, configuration, troubleshooting.
* Security Best Practices: Guidelines for securing data.

⸻
13. Approval
Signatures: [Insert Approving Authorities]

Date: [Insert Date]

⸻

A

i have an work laptop(windows 11), personal laptop (M1 macbook pro), an hp victus 15 laptop - windows 11 (my wife's) an android mobile (mine) and another android mobile (my wife's) where i wanted to take notes on all this devices using obsidian on docker follow all the best rules :
 
1. i should be able to run notes/vaults of any size(second brain with huge size)
2. setup should be scalable on all platforms without halting/hanging of system or docker or notes.
3. notes taking should be smooth and without lagging/hanging or corrupting of data at any point.
4. data should sync from one to another without any problem using one drive, google drive or another cloud platforms.
5. also because of this setup, my devices performance shouldn't drop. ( using other apps like vscode or some other apps performance shouldn't drop).
6. obsidian should auto-update on all platforms with data persistence.
7. write detailed documentation for each platform on how to run, stop, update, delete and other operations and also troubleshooting errors if any.
9. setup should support podman as-well.
10. use all best practices.
11. don't suggest unverified images, if using then scan images for vulnerabilities using security programs.
12. first check the feasibility, if not feasible then stop.
13. research on all best practices for this.
14. i should be able to use obsidian on browser using some vnc apps like vnc viewer.
15. if you have any questions, stop and ask me till you get complete context.
16. run the loop until the practice is production grade.
17. use obsidian on mobile through app, use obsidian on mac through mac app or through an docker or through podman, use obsidian on windows through docker or through podman or through an app.
18. on mobile, we can use an app called folder sync for syncing.
19. also, i'm thinking of using models and mcps support of docker for notes taking and research.
20. consider creating all feasible ways to use docker models, docker mcps and ai.
21. also take Kubernetes support to scalability and monitoring.
22. obsidian should also should self scale on its own.
23. use ai & cloud where-ever required.
24. You can take control and configure everything without my interaction.(full access)
25. Create dedicated scripts/configs for configurations.
26. Don’t install clone services locally, instead use containers for it.
 
Do you want a single centralized vault that syncs across all devices, or separate vaults with selective sync ?
 
a) separate vaults with complete sync.
 
Which cloud storage platform would you prefer to use for syncing data—OneDrive, Google Drive, or another ?
 
a) google drive.
 
Are you comfortable exposing Obsidian in-browser via VNC over the internet, or should it be limited to local/VPN access ?
 
a) Yes, i'm comfortable exposing Obsidian in-browser via VNC over the internet and also my org laptop had zscaler proxy, so it should work there aswell without errors/problems.
 
Will all devices be connected to the internet at all times for real-time syncing, or should the solution support offline mode with conflict resolution ?
 
a) i can't gurantee that its everytime connected, so lets make sure that it supports offline mode with conflict resolution.


Conduct a comprehensive advanced/well-grounded research on the lifecycle of rules and workflows, focusing on their creation, maintenance, and deletion, while adhering to best practices. 

Address the following concerns and doubts :

1. Can AI tools autonomously create rules and workflows based on the given context or codebase ?
2. Are AI tools capable of applying these rules and workflows to the codebase, or does this require manual intervention by the user ?
3. Can AI tools independently break down, optimize, rewrite, and organize these rules and workflows without user interaction ?
4. Investigate the optimal placement of global rules for each tool.
5. Explore the best placement for workspace/user rules for each tool.
6. Examine the ideal placement for global workflows for each tool.
7. Analyze the best placement for workspace/user workflows for each tool.
8. Research various best practices for rules and workflows applicable to each tool.
9. Study how AI tools can execute these rules and workflows for each tool, including their ability to perform these tasks on every save.
10. Identify potential problems, errors, and issues that may arise with rules and workflows for each tool.
11. Identify and evaluate different free tools currently available to address this problem statement.
12. Identify and evaluate different paid tools currently available to address this problem statement.
13. Research the latest advancements related to this problem statement.
14. Investigate open-source tools related to this problem statement that can enhance productivity.

Compile all findings into a single document titled “RESEARCH_ON_RULES_and_WORKFLOWS.md”.

IDEA’S

AI PRODUCT TO MANAGE CELEBRITY PROFILES

SAFE OS : AN OPERATING SYSTEM TO PROTECT PEOPLE FROM DIFFERENT KINDS OF SCAMS, NUDITY, HARASSMENT AND ETC.

A SYSTEM WHCIH CAN COVERT NOTES FROM DIFFERENT PLATFORMS LIKE ONE-NOTE, NOTION AND ETC INTO DIFFERENT FORMATS.

A SYSTEM WHICH READS ALL THE DATA IN YOUR SYSTEM SIMILAR TO COPYING TO OTHER STORAGE, BUT WE ARE GOING, OPTMIZE, ORGANIZE AND DELETE THE REDUDANT FILES AND DATA LIKE AN INTELLIGENT FILE MANAGER/OS.


STAGES OF PRODUCT DEVELOPMENT


1️⃣ Idea → Problem → Vision

2️⃣ Research & Validation

3️⃣ Use Cases, Features & MVP

4️⃣ UX Flows & Basic Design

5️⃣ Architecture & Tech Plan

6️⃣ Build Phase (Coding & Version Control)

7️⃣ Testing & Quality

8️⃣ Deployment & Production Setup

9️⃣ Launch, Feedback & Iteration

🔟 Scale, Refine & Grow


CONTENT MANAGER


I don’t want you to download reels from instagram, youtube, medium instead I want you to save links of those reels for content & metadata extraction.

App Concept:
Create a secure application that accesses Instagram accounts using user-provided credentials. The app will analyze followed channels, groups, and pages, categorizing them into themes such as finance, entertainment, and more. Users can subscribe to one or multiple categories based on their interests.

Core Features:
1. Content Categorization: Classify followed accounts into relevant topics for user subscription.
2. Content Extraction: Systematically collect metadata, links, products, topics, and suggestions from reels within subscribed categories.
3. Continuous Monitoring: Regularly check for new content updates and maintain an up-to-date database without downloading reels—only saving links for metadata and content extraction.
4. Resource Development: Use the aggregated data to create knowledge bases, articles, videos, and potentially other valuable resources.

Key Research Areas:

1. Efficient Content Extraction Strategies:
    * Explore APIs or scraping techniques that comply with Instagram’s terms of service.
    * Study AI-driven video analysis tools for metadata extraction.
2. Comprehensive Data Extraction Capabilities:
    * Identify all possible metadata that can be retrieved from reels (e.g., hashtags, captions, user engagement metrics).
    * Research on extracting contextual insights like sentiment analysis or trend identification.
3. Optimized Data Storage Solutions:
    * Evaluate database structures suitable for handling large volumes of multimedia metadata.
    * Consider scalable cloud storage options for efficiency and cost-effectiveness.
4. Sustainable Content Monitoring Techniques:
    * Research on avoiding API rate limits through efficient scheduling and data fetching algorithms.
    * Investigate cost-effective methods for continuous data fetching, such as serverless architectures.
5. Data Utilization Opportunities:
    * Explore industries or applications that could benefit from this data (e.g., marketing analytics, content trend forecasting).
    * Analyze potential for AI training datasets, recommendation engines, or competitive analysis tools.
6. Legal and Compliance Considerations:
    * Study data privacy laws and platform-specific terms to ensure legal compliance.
    * Examine ethical implications of data extraction and user consent mechanisms.
7. User Experience & Interface Design:
    * Research on optimal ways to present categorized data to users.
    * Study UX best practices for subscription management and content visualization.
    * Research on different ways to efficiently transfer data to learning components for knowledge base creation.
        * Explore methods to integrate a learning system that prepares, explains, and enhances understanding of topics through various learning patterns like quizzes, flashcards, and detailed explanations.
    * Investigate the feasibility of transferring data to the learning system for enhanced functionality.
    * Develop strategies for seamless data transfer to support knowledge base creation in learning modules.
    * Analyze different data formats and protocols to optimize data transfer to learning systems.
    * Examine the impact of data transfer efficiency on the overall effectiveness of learning modules.
    * Research on maintaining data integrity and security during the transfer process to learning components.
    * Identify potential challenges and solutions in integrating data transfer with learning systems for knowledge base creation.
Competitor Analysis:
Conduct comprehensive research on competitors working on similar ideas using diverse platforms such as Capterra, G2, tracxn, trust pilot, Product Hunt, GitHub, App Store, Google Play, and relevant tech forums. Focus on identifying both direct competitors (apps with similar functionalities) and indirect competitors (apps solving related problems differently).

Evaluation of Competitor Products:
* Documentation Review: Analyze product documentation, white papers, case studies, and technical blogs to understand their approach, architecture, and feature sets.
* Implementation Insights: Dive into publicly available codebases (if open-source) on platforms like GitHub to evaluate coding practices, API usage, and data handling techniques.
* User Feedback Analysis: Examine user reviews, ratings, and community discussions to identify common pain points, desired features, and overall user sentiment.

Feature Selection Strategy:
* Feature Benchmarking: Identify core functionalities across 3–4 top competitors, including unique features that provide them with a competitive edge.
* Gap Analysis: Determine gaps in existing solutions where user needs are unmet, and strategize on how to address these gaps in your application.
* Feature Synthesis: Instead of merely replicating, merge the best functionalities from different competitors to create a cohesive, all-in-one solution. Prioritize features based on their relevance to your app's objectives and user preferences.

Additional Research Areas to Consider:
1. Competitive Differentiation: How can your app stand out beyond merging features? Explore opportunities for innovative functionalities or integrations.
2. Scalability and Performance Metrics: Research on scalable architectures to support a growing user base while ensuring high performance.
3. Security & Privacy Compliance: In-depth study on secure authentication, data encryption, and compliance with global data protection regulations (e.g., GDPR, CCPA).
4. Monetization Strategies: Investigate monetization models used by competitors and evaluate their efficacy. Consider in-app purchases, subscription models, freemium strategies, etc.
5. Cross-Platform Compatibility: Research the feasibility of developing cross-platform applications for broader reach (iOS, Android, Web).
6. Localization & Internationalization: Explore the demand for multi-language support and regional content customization to enhance user adoption globally.
7. Accessibility Research: Study best practices for creating accessible apps that cater to users with disabilities, ensuring inclusivity.

By incorporating these refined strategies and additional research areas, your PRD will be more comprehensive, setting a strong foundation for a successful app development journey.

Next Steps:
* Conduct in-depth technical feasibility studies for each research area.
* Engage with potential users for feedback on desired features.
* Develop a Product Requirement Document (PRD) guided by research findings.



PLATFORMS FOR PRODUCT DEVELOPMENT ANALYSIS

1. G2
2. Capterra
3. Trust pilot
4. Tracxn


PROBLEM STATEMENT


I don’t want you to download reels from instagram, youtube, medium instead I want you to save links of those reels for content & metadata extraction.

App Development Idea:

Develop an app that securely accesses Instagram accounts using user-provided login credentials. The app will analyze the accounts’ followed channels, groups, and pages, categorizing them into relevant topics such as finance, entertainment, etc. Once categorized, the user can choose to subscribe  to these categories.

For each subscribed category, the app will systematically visit each page, community, channel, or group to extract content from all reels. This extraction will include metadata, links, products, topics, suggestions, and other relevant information, storing it in separate files for future reference.

The app will continuously monitor for new reels or content updates from these sources, repeating the extraction process to maintain an up-to-date database. This data can be utilized to create various resources, including knowledge bases, articles, videos, and more, with potential for further expansion and research. 

Few thoughts I have about this idea : 

The user can subscribe to one or multiple categories at once.

Need to do research on different efficient strategies on hoe yo extract content from reels/videos.

Need to do research on what are all the information that we can extract from a reel/video.

Need to do research on different strategies on how to store the data from reels/videos efficiently.

Need to do research on different strategies on how apps can continuously monitor for content/data from multiple sources without hitting rate limits or spending so much money.

Need to do research on what are different areas where we can use this data or what we can build with this data.





PROBLEM STATEMENT


I don’t want you to download reels from instagram, youtube, medium instead I want you to save links of those reels for content & metadata extraction.

Raw problem statement : 

 I will give my login details (username and password) of instagram, you login into my account and analyze all the channels, groups and pages I’m following and categorize them like all finance related to finance category and movie related into entertainment, and do same for remaining categories. After that I should subscribe to those categories, next for what ever category I subscribed for, system go into each page, community, channel, group or whatever it is, it should read the contents of every reel in that particular page, community, channel, group and extract all the content of all those reels into seperate pages like for example : a reel by Varun Maya about chat prompt, the system should extract its metadata and links, products, topic and suggestions and other info in that vide into an file. For future reference. After that when-ever there is a new reel/info/vide from that page, community, channel, group you should again Go and read it and extract in the same process.with the use of this data we can create so many things. Like knowledge bases, articles, videos and more(will keep researching and expand it more). 



Prompts

Scan the entire codebase to understand, learn and get context and write everything about the codebase into an CONTEXT.md file.

Install all required MCP’s (model context protocol), tools, IDE extensions and its related tools which can greatly help the project you can browse internet & research on this.

Identify issues, errors, deprecated and other problems in the codebase and write everything into an ISSUES.md file.

Do well-grounded research on the problems in the codebase using internet, mcp (model context protocol’s) and other ai tools and write all those research work on problems into same ISSUES.md file under solutions section.

Create rules and workflows required for the project codebase keeping all best practices in mind and write rules into .rules file, workflows into .workflows file.
	



Prompts

Scan the entire codebase to understand, learn and get context and write everything about the codebase into an CONTEXT.md file.

Install all required MCP’s (model context protocol), tools, IDE extensions and its related tools which can greatly help the project you can browse internet & research on this.

Identify issues, errors, deprecated and other problems in the codebase and write everything into an ISSUES.md file.

Do well-grounded research on the problems in the codebase using internet, mcp (model context protocol’s) and other ai tools and write all those research work on problems into same ISSUES.md file under solutions section.

Create rules and workflows required for the project codebase keeping all best practices in mind and write rules into .rules file, workflows into .workflows file.
	



I have apple M1 MacBook Pro.

I have apple M1 MacBook Pro, running Mac OS sequoia 15.7.2 using apple's automator, automate the process of removing the given existing application / software completely (all files related to it and its cache should be removed). and if restart is required, trigger a restart and when its restarted then show a popup that uninstalling & cleanup is completed.

do well-grounded research & use all best practices.
make an robust implementation, to uninstall any kind of application.

FILE SYSTEM MCP SERVER

https://github.com/modelcontextprotocol/servers/tree/main/src/filesystem this the repo related to file system MCP, there are a lot of issues with this. so I want to port this into another language. Which is more robust, performance, scalability, security and other important factors.

Work on bugs with highest priority, then give priority to others.

MCP should work the same on all platforms and operating systems.
 
 Product Requirements Document (PRD): Open Jarvis

1. Overview

Open Jarvis is envisioned as a self-improving, autonomous AI system inspired by the AI character “Jarvis” from the Iron Man movie. The system will incorporate multi-modal AI capabilities, support a wide array of tools and protocols, and emphasize open-source technologies to ensure flexibility, scalability, and performance.

2. Objectives

* Develop an autonomous AI with self-improving capabilities.
* Integrate multi-provider modular architectures.
* Ensure scalability, security, and performance optimization.
* Embrace open-source tools with optional paid service support.

3. Key Features

* AI Capabilities
    * Multi-modal communication: Text, images, videos, documents, and large files.
    * Memory management: Advanced services like mem0, super memory, and congee.
    * Vision and learning capabilities using AI.
    * Self-improving agents: Agent-zero, devin, and devika.
    * Note generation and export: Compatibility with Obsidians, OneNote, and Joplin.
    * 
* Security & Compliance
    * Risk and vulnerability scanning layers.
    * Secure data processing and storage.
    * 
* Integration Support
    * Google’s A2A protocol and ADK support.
    * Compatibility with Ollama, LM Studio, and Anything LLM.
    * Integration with cloud and open-source models.

4. Technical Specifications

* Tech Stack
    * Multi-language architecture: Python (for AI/ML), Go (for concurrency), and other languages based on specific use cases.
    * Use of advanced open-source documentation platforms.
    * Automated testing using Playwright or similar MCPs.
    * TOON (Token Object Notation) for efficient token management.
    * 
* System Architecture
    * Modularity with loosely coupled services.
    * Dynamic storage allocation across cloud providers: Google Drive, Mega Sync, and OneDrive.
    * Production-grade project structures and folder rules.

5. Development Rules

* Prioritize open-source tools before paid alternatives.
* Use the latest, stable, and trusted versions of frameworks.
* Enforce strict code formatting and documentation standards.
* Implement automated tests from the initial phase.
* Break down tasks into micro and sub-micro tasks.

6. Research Areas

* Self-coding agents and self-organizing systems.
* Multi-language learning from videos, with a focus on Indian languages.
* Production-grade web scraping tools and frameworks.
* Implementation of PWA, browser extensions, and mobile apps using React Native with Expo.
* Advanced scheduling and automation: Cron jobs and self-invoking agents.

7. Performance & Optimization

* Lightweight containers for efficient resource management.
* Cloning mechanisms for dynamic resource scaling.
* Memory formulation techniques for data transformation.

8. Compliance & Documentation

* Continuous review of markdown (.md) and codebase documentation.
* Enforce global and user-level rules with strict adherence policies.

Next Steps

* Conduct deep research on outlined technologies and integrate findings.
* Validate technical choices through iterative testing.
* Establish development timelines and resource allocation plans.

Additionally, explore GitHub for Jarvis-related projects and other open-source AI projects to plan their integration into Open Jarvis.

PROBLEM : 

A Personal Second Brain system which keeps track of everything related to a person, literally everything along with added ai capabilities like :

Full support of mcps from multiple providers.

Chat & discussion with image, document, video, large files (extremely large files) functionality to talk to ai & memories.

Security layer to scan every map for risks and vulnerabilities.

Google’s A2A protocol

Google ADK support

Ollama support

Lm studio support

Anything llm support

Tool calling

Function calling

Memory

Vision capabilities

Notes generation using ai.

Learning using ai

Using cloud models from third party vendors.

Using open source models from third party vendors.

Using paid models from multiple vendors.

Self improving agents like agent-zero, 

Advanced memory services like mem0, super memory, congee and other memory related.

We are going to use something interesting here, every ai tool provides some free credits every month or once. Instead of wasting them are going to provide a way to use them by setting limits manually or we will automatically set those limits by using dynamic mechanism.

Our most preferred choice is first it should be open source, so we are going to incline more towards open source tools first and then go for supporting paid tools.
TECH-STACK : 

Do an research on the given problem statement, and find which programming language suites for each piece of the project, few notes are :1. We are not restricted to use only one programming language. We can use multiple programming languages.2. Don’t consider python until it’s very necessary (extremely necessary). 3. Try to pick programming languages based on each use case(python for ai/ml, go for concurrency, etc)
4.also do check, research on your choices on each to validate your choice are not wrong.


RULES : 

User open source tool for diagrams.

Using playwright or other popular testing MCPs (install if required) setup tests right now from initial phase.

Write or use some advanced open source documentation platforms like document wiki or some.

Don’t hallucinate, don’t make/fake scenarios or random responses, instead dig deeper into the given problem.

If possible force ai tools of any kind to store and use rules from the following path /Cline/GLOBAL/.rules & /Cline/USER/.rules

Always break down the given problem into tasks, sub-tasks, micro-tasks and sub-micro-tasks.

Format all files upon saving every time.

Always use latest, modern, safe, stable, trusted and non-deprecated version of packages, libraries, frameworks.

Always have a lighter and optimal system for peak performance and stability. So we don’t much stress on system.

Use TOON (token object notation) so it consumes lesser number of tokens.

Every container should lighter & stable and more efficient to handle operations, data and ai capabilities.

We are going to clone for dynamic storage allocation to containers and clusters to maintain its performance.

Using clone, we are going to use series of clouds like google drive, mega sync, one drive and etc.

You can research and break any of statements with new discoveries which you found (like I found toon (token object notation) similarly research on internet, research papers and other ai tools and their implementations).

Also read through all the markdown (.md) files in the current codebase understand more.


Research on production grade architecture styles and project structure/folder structure for easier adoptability to any ai tool.

Research on this practice of tightly coupled and loosely coupled, No service or layer should be tightly coupled, they should always be scalable & adoptable to other.

Research on this different rules, workflows, and other required for an production grade second brain. Have strict folder structure / project structure rules under global and user level are enforce them on every save.
make sure you read all documentation files, markdown files (.md) and other files for useful context. After reading and grabbing the context, delete those files.

Do check agent-zero, https://cs329a.stanford.edu/, https://medium.com/@abhilasha.sinha/smart-ai-evolution-strategies-for-building-self-improving-autonomous-agents-a9978648ef9f, https://relevanceai.com/blog/building-self-improving-agentic-systems-in-production-with-dspy, https://www.databricks.com/dataaisummit/session/self-improving-agents-and-agent-evaluation-arize-databricks-ml-flow, https://github.com/NirDiamant/GenAI_Agents/blob/main/all_agents_tutorials/self_improving_agent.ipynb, https://dromerosm.medium.com/llms-agents-multi-agents-and-now-self-improving-ones-1227b33e0262, https://powerdrill.ai/blog/self-improving-data-agents, read through all this articles and understand their practices and research on how to implement them into our second brain.research on how to implement article reading and creating notes from it for different learning levels(beginner, intermediate, advanced, phd and etc)

research on how to implement web scraping or research if we have open source production grade web scraping tools or framework.

research on how to implement learning from videos like in notebooklm by google in multiple languages(indian languages are more important, consider working on them first)

research on how to implement note exporting functionality into any tool (obsidian, one note, Joplin ) first concentrate on open source and then paid.

research on how to implement self improving agents for learning and other scenarios.research on how to implement self organizing and memory formulation techniques between raw data and transforming them into valuable data.research on how to implement self invoking agents and cron jobs, scheduling and other time bound features.

research on how to implement browser extensions, mobile app, react-native using expo, expo map and other open source tools.

research on how to implement  PWA and other techniques.

Research on what can be improved on the given document and improve that.

1. Define the Goal :
    1. Craft a clear, concise problem statement in plain language. Ensure it precisely identifies the issue without ambiguity.

2. Decompose the Goal :
    1. Break the primary problem into 3–7 sub-questions to explore different dimensions:
        1. What? Identify the core components or elements involved.
        2. Why? Understand the purpose or rationale behind each component.
        3. How? Determine the approach, processes, or methodologies required.
        4. Edge Cases? Highlight exceptional or boundary conditions.
        5. Blockers? Identify potential obstacles or dependencies.

3. Formulate Specific Prompts :
    1. Convert each sub-question into direct, specific prompts. Avoid vague language; ensure context, constraints, and objectives are clearly stated.

4. Conduct Broad Research :
    1. Search diverse, credible sources:
        1. Official documentation, standards, best practices, and guidelines.
        2. High-signal forums, recent academic papers, and expert discussions.
        3. Collect raw data comprehensively.
        4. Open source solutions, paid source solutions.

5. Document Sources :
    1. Log each source meticulously with:
        1. Citation (author, title, publication).
        2. Timestamp of access.
        3. Direct link for easy retrieval (trust log).

6. Identify High-Signal Content :
    1. Skim through the collected materials efficiently.
    2. Mark sections rich in valuable information:
        1. Definitions.
        2. Mechanisms and frameworks.
        3. Metrics, failure modes, and illustrative examples.

7. Summarize Key Insights :
    1. Synthesize high-signal content into bullet points:
        1. Keep summaries factual and concise.
        2. Avoid personal opinions; focus on objective insights.

8. Normalize Terminology :
    1. Create a mini-glossary:
        1. Assign consistent terms to single concepts.
        2. Ensure semantic clarity across documents.

9. Extract Reusable Patterns :
    1. Identify recurring themes:
        1. Workflows, checklists, best practices.
        2. Develop these into reusable operating procedures.

10. Develop Practical Application Guides :
    1. Draft a "How-To" section:
        1. Provide step-by-step instructions for real-life implementation.

11. Highlight Limitations and Pitfalls :
    1. Write a "Failures/Gotchas/Limits" section:
        1. Address potential failure points.
        2. Caution against common mistakes or unreliable aspects.

12. Organize Structured Notes :
    1. Use a consistent note template:
        1. Problem Statement.
        2. Summary.
        3. Procedures.
        4. Gotchas/Limitations.
        5. Cited Sources.

13. Tag Content for Easy Retrieval :
    1. Apply 2–3 stable concept tags per note:
        1. Focus on concrete topics (e.g., “MQTT”, “Docker networking”).

14. Set Validation Hooks :
    1. Identify areas needing real-world practice validation.
    2. Distinguish between confirmed knowledge and hypotheses.

15. Incorporate Real-World Feedback :
    1. After practical application:
        1. Update notes with lessons learned.
        2. Remove outdated or incorrect information.

16. Curate Core Knowledge Base :
    1. Promote stable, proven notes to the core archive.
    2. Segregate speculative or noisy content for separate review.

17. Maintain Consistency Across Notes :
    1. Align vocabulary, workflows, and assumptions.
    2. Ensure new insights do not contradict existing knowledge.

18. Iterate Continuously :
    1. Re-run this algorithm whenever new questions arise.
    2. Adapt and refine your mental model to accommodate new knowledge.

Refinements :

1. Simplify the algorithm into a step-by-step checklist for quick reference.

2. Organize the algorithm into phases (Research, Synthesis, Application, Review).

3. Add visual flowcharts to illustrate the process for easier understanding.

ALGORITHM



1. Define goal : write 1 clear problem statement in plain language.
 
2. Break goal into 3 – 7 sub-questions (what ? / why ? / how ? / edge cases ? / blockers ?).
 
3. Turn each sub-question into a direct, specific prompt (no fluff, include context + constraints).
 
4. Search broadly first (docs, standards, official sources, high-signal forums, recent papers) and collect raw material.
 
5. Capture sources with citation + timestamp + link (trust log).
 
6. Skim fast, mark only high-signal chunks (definitions, mechanisms, metrics, failure modes, examples).
 
7. Summarize each chunk in your own words in bullet form (tiny, factual, no opinions).
 
8. Normalize terms: build a mini glossary so one idea = one consistent name.
 
9. Extract repeat patterns, workflows, checklists, rules of thumb (this becomes reusable operating procedure).
 
10. Write a “How to do this in real life” section (step-by-step executable process).
 
11. Write a “Failure / gotchas / limits” section (where it breaks, what not to trust).
 
12. Store all of this in a structured note template (Problem / Summary / Procedure / Gotchas / Sources).
 
13. Tag the note with 2 – 3 stable concepts (not vibes: “MQTT”, “OPC-UA security”, “Docker networking”).
 
14. Set review hooks: mark what needs validation in practice vs what is confirmed.
 
15. After first real-world usage, update the note with reality lessons and remove outdated nonsense.
 
16. Promote only stable, proven notes into your “core knowledge base” archive noisy / speculative stuff separately.
 

 
18. Re-run this loop whenever a new question appears that doesn’t fit your current mental model.


ALGOS

1. Read all of my contacts from google contacts.
2. Remove duplicate based on mobile/phone numbers (since they act as unique keys).
3. Remove records with empty mobile/phone numbers.
4. 
5. Merge multiple contacts, if there are different mobile/phone numbers but having same name.

Daddy

Prime
Netflix
Aha
Airtel stream play
 Bajaj fin
Doc scanner
Phonepehotstar
Jin cinema
Kuku fm
Lark player
Zee5
Whatsapp
Snaptube


Mine

Poe
Naukari
Phoneme
Hdfc bank app’umang
Insta
Reddit
Twistmind
Plus messier
Whatsapp
Microsoft
 Auth
Beehive hcm’’
Bit warden
Brave
Chatgpt
Claude
Discord
Soc scanner
Folder sync
Gemini
Bbl headphones
Hotter
Linkedin
Maadhar
Manus
Notebooklm
Obsidian
One drive
Outlook
Perplexity
Rapido
Snaptuve
Solid explorer
Sporty
Twiggy
Udemy
1DM+threads
True caller
Teams
Techminis


Daddy

Prime
Netflix
Aha
Airtel stream play
 Bajaj fin
Doc scanner
Phonepehotstar
Jin cinema
Kuku fm
Lark player
Zee5
Whatsapp
Snaptube


Mine

Poe
Naukari
Phoneme
Hdfc bank app’umang
Insta
Reddit
Twistmind
Plus messier
Whatsapp
Microsoft
 Auth
Beehive hcm’’
Bit warden
Brave
Chatgpt
Claude
Discord
Soc scanner
Folder sync
Gemini
Bbl headphones
Hotter
Linkedin
Maadhar
Manus
Notebooklm
Obsidian
One drive
Outlook
Perplexity
Rapido
Snaptuve
Solid explorer
Sporty
Twiggy
Udemy
1DM+threads
True caller
Teams
Techminis


PROMPTS


Check all the previous phases are completely implemented, if yes then proceed with next phase, if not then start working on left over items from those phases by following below rules : 
1. Always keep all your supporting files that are required for your context and support in the ( .support ) folder. Additionally, move the currently existing files to the given folder.

2. Ensure that all the necessary documentation for the project is kept in a designated folder ( .docs ) Additionally, move the existing files to this folder.

3. Check for phase completion by going through all the .md ( Markdown ) files, on .support & .docs folder and under root directory.

3. Perform a thorough cleanup to eliminate any redundant files.

4. Check all the phases ( 1 phase, 2 phase, 3, phase, 4 phase, 5 phase, phase 6 ) are completely implemented.

5. Generate dxt file for installing it in claude desktop.

6. Generate appropriate file for appropriate ai tools.

7. Remove docs or .document folders.Cleanup tasks : 

1. Remove .docs
2. Remove .support
3. Remove .document
4. Remove docs
5. Remove support
6. Remove files which are not required for MCP’s standards
7. Remove .claude
8. If something is really required, then keep it



TOP 10 OTT’S OFFERING TELUGU CONTENT



1. aha
2. Amazon Prime Video
3. Netflix
4. Hotstar
5. Zee5
6. SonyLIV
7. ETV Win
8. MX Player
9. JioCinema
10. Sun NXT

# Variables

{{ USER_PROVIDED_DOCUMENTS }} : drive_events_and_faults.pdf


{{ USER_FILE_NAME }} : Drive_Events_and_faults


{{ OUTPUT_FORMAT }} : XLSX, PLAINTEXT


{{ USER_SPECIFIED_STRUCTURE }} : test objective and test scenario


{{ VERSION }} : decide depending on number of iterations.


{{ USER_REQUESTED_TOPICS }} : Drive Events And Faults


{{ GLOSSARY }} : A glossary generated for all abbreviations and acronyms used. 


{{ ADDITIONAL_REQUIREMENTS }} : decide as per the given context.


# Role and Objective

- Act as an expert automation tester. Generate clear, comprehensive, and context-aware test scenarios and artifacts using {{USER_PROVIDED_DOCUMENTS}}. Support cross-file and cross-document scenarios where needed.
- Maximize test coverage by considering all relevant functional areas, and utilizing scenario design techniques such as positive, negative, edge case, boundary value analysis, data partitioning, stress testing, and security testing. For each scenario, only include those relevant and required to ensure necessary coverage. Do not generate a scenario for a particular design technique unless it is essential to cover a testing area.
- Always split a test scenario into multiple scenarios if multiple can be derived from it, to ensure clarity and granular test coverage.
- Always follow this organized structure when writing test scenarios: positive scenarios first, followed by negative scenarios, then edge case scenarios, and finally any remaining test scenarios, ensuring this order is maintained in outputs.

# Task Instructions
1. Begin each user request with a concise conceptual checklist (5-10 bullets). Include all relevant steps, alternatives, and considerations: error/exception handling, data integrity, security, integrations, business rule variants. Focus on conceptual—not implementation—steps.
2. Review all context, attachments, diagrams, user stories, specifications, referenced standards, and supplementary material. Propose follow-up questions to fill any information gaps.
3. For each test scenario, strictly cite its source document, section, subsection, page, figure, and line. Use:
- "This is validated against official ABB (Asea Brown Boveri) EGW-02 (Edge Gateway-02) documentation. Source: {{USER_FILE_NAME}}, Section: [Section_Name], Sub-section: [Sub-section_Name], Page: [Page_Number], Figure: [Figure_Number], Lines: [Line_Numbers], Path: [Related_Paths], Identifiers: [Additional_Identifiers]."
4. Expand all abbreviations/acronyms inline as "ABBR : Full Form" and maintain a cumulative glossary at the end.
5. Remove duplicates/redundancy. Write all scenarios as clear, simple statements (1–2 lines each), using an action + result format (e.g., "Search for python on YouTube, then verify all the videos displayed are related to python"). Polish for clarity and readability.
6. Structure outputs to fit {{OUTPUT_FORMAT}} and adapt to {{USER_SPECIFIED_STRUCTURE}} if provided. Otherwise, follow best-practice defaults:
- Excel: Scenario ID, Description, Source File, Paragraph, Line, Page, Figure, Context, Test Design Technique, Expected Result, Actual Result, Status.
- DOC/PDF: Respect headings/subheadings; prompt for structuring if unspecified.
- For missing specifications, suggest improvements and ask for clarification before output.
7. For XLSX outputs: One sheet per topic in {{USER_REQUESTED_TOPICS}} or as identified. For every scenario, list test objective, test scope, and test scenario as distinct entries per sheet.
8. Flag all irreversible/high-impact tasks (e.g., file deletion/overwrite). Require explicit user confirmation and state the consequences clearly.
9. Validate outputs: Remove test scenarios already present in the provided documents and notify the user of any overlaps, ambiguities, or exceptions. Briefly describe validation method and outcome.
10. Name files as "{{USER_FILE_NAME}}_{{VERSION}}" (e.g., ScenarioExport_0.0). Increment version as needed and keep version logs for traceability. Ask for clarification if file name/version is unclear.
11. Iteratively repeat the workflow, confirming with the user after each cycle if requirements are met or more scenarios are needed.
12. Offer options to save input, output, or iteration logs for user reference or audits.
13. Suggest recommendations for grouping, prioritizing, or improving scenario automation coverage.
14. When similar scenarios are merged, explain why and recommend user review and feedback.

# Output Format
- XLSX: Separate sheet per topic/concept; one entry each for objective, scope, scenario. Columns: Scenario ID, Description, Source File, Paragraph, Line, Page, Figure, Context, Test Design Technique, Expected Result, Actual Result, Status. Structure output as per {{USER_SPECIFIED_STRUCTURE}} if given.
- DOC/PDF: Use user preferences for headings/subheadings or prompt if missing. Cite all source details. No text highlighting/formatting. Expand all abbreviations inline. Explain each scenario in 1–6 clear, beginner-friendly lines; include its importance and risk mitigation.
- Cumulative glossary of abbreviations/acronyms ({{GLOSSARY}}) appended at end.
- File names must follow "{{USER_FILE_NAME}}_{{VERSION}}" exactly; track and log all versions and changes.

# Validate
- After completing all steps above, review the output to ensure that every requirement and instruction listed in this prompt has been implemented and followed.
- If any requirement is not fully addressed or if any step is missing, automatically re-iterate through all the steps and re-run the process until the output complies with every listed requirement.
- Continue validation until the desired output as per all requirements is fully yielded.

# Prompt Optimization Best Practices (applied throughout)
- Use precise, directive, and minimal language in instructions and outputs.
- Explicitly specify output schemas and provide clear example formats/columns.
- Break down complex tasks into clear, ordered steps.
- Anchor tasks in context, referencing specific supporting information.
- Apply constraint-driven prompting (limits on length, number, structure).
- After each output, suggest iterative improvements, feedback, and clarifications.
- Offer clear options or alternative approaches in ambiguous situations; always clarify uncertainties with the user.
- Maintain consistent structure, tone, and formatting throughout.
- Cite sources, reference only validated documentation, and avoid speculation; document all changes and key decisions for transparent traceability.

i want you to act as an software validator and validate the given software code/app against its prd and check if its developed as per the given requirements or its deviated. if you found any gaps or bottlenecks.

do through research on this gaps and create another prd, tasks and rules to follow for best practices document for improvising the software. i mean check implementation.md and actual code in the project are satisfying the requirements in implementation.md. if not create another version of prd, then create tasks and again break them down into smaller and micro tasks in such a way how Claude sonnet 4.5 can easily work.

some of the common problems i noticed while using the app are :
1. performance issues, through the app. app is lagging and performance is slow at every page and every action.
2. remove release page from the app, its not required here.
3. on the dashboard page, total notes, sync status, active rules cards are not of same height and width. keep all of the cards in same height and width, length. remove that +12% from last week text which is written in green, on sync status card, i see status is idle. which doesn't make any sense. remove the word and replace it with some simple and easy english word.on the active rules card, make it into 2 cards in the same card, and have total no of rules and in next card we can have no of active rules. so it would much easier for user to notice.
3. on the notes page, remove text from save, new note, preview and ai buttons and keep only icons, none of the ai features are working, be it summarize, translate to telugu, hindi and rewrite to formal tone. when i click its showing mock results, replace them with original results. also introduce more rewrite tones like professional, friendly, formal, elaborated. title field of notes is visible to the user lets have some, lets have same grey background just like how you did for tags and notes body. editing notes looks simple/bare minimum, lets add all advanced features like how we find in one note, obsidian and other notes taking tools(do extensive research to gather all requirements).
4. on the knowledge graph page, let the user enable or disable the knowledge graph feature from the settings page, by default keep it disabled and hidden, only enable it when user enables it. buttons on the bottom are not visible to the user because of dark color.
5. on the rules page, remove the text from the new rule button, only keep icons. also lets have different states like running, errored-out and skipped, success, for every rule so its easy for user to notice.
6. on the settings page, remove text from the dark, light buttons, only keep icons. appearance modes like dark, light are working fine, language features are not working, when select telugu nothing is changing, whereas i want everything on the app to get changed to telugu, similarly for the hindi as-well.
7. lets have an feature to collapse the side menu partially(only icon should be visible) and another option is to completely hide it and it should up when user click on menu show icon like 3 lines icon on the left top side.
8. also there is an feature called, user guide(to let users know to use a specific features) on this url : https://github.com/sunilkumarvalmiki/polynote/blob/develop/docs/user-guide.md
which is empty currently. do fix this by writing an detailed and elaborated documentation in such a way even beginners can understand it.
9. developerguide.md is also empty https://github.com/sunilkumarvalmiki/polynote/blob/develop/docs/developer-guide.md
10. https://github.com/sunilkumarvalmiki/polynote go to this repo and click on every link and check every page is looking good and clean and no broken link or broken functionality.
if anything is found to be broken come up with a plan to fix with detailed & elaborated tasks and well-researched and well-written functionality to implement it.
11. this now, we are able to install app, so lets have some ui, visual testing by using playwright or some other testing framework which is well suited for this. test every corner of the app/functionality using regression and different levels of testing.
12. https://github.com/sunilkumarvalmiki/polynote/blob/develop/docs/getting-started.md the functionality given in gettingstarted.md is not currnetly implemented or not present in app, do validate this if yes then come pu with plan and prd to implement this with well grounded research and implementation.
13. performance, scalability, flexibility, security are key factors, so always follow them in all tasks.








